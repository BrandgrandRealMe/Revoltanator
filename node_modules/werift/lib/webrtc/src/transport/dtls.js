"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RTCDtlsParameters = exports.RTCDtlsFingerprint = exports.RTCCertificate = exports.DtlsStates = exports.RTCDtlsTransport = void 0;
const x509_1 = require("@fidm/x509");
const debug_1 = __importDefault(require("debug"));
const rx_mini_1 = __importDefault(require("rx.mini"));
const promises_1 = require("timers/promises");
const src_1 = require("../../../dtls/src");
const const_1 = require("../../../dtls/src/cipher/const");
const cipher_1 = require("../../../dtls/src/context/cipher");
const src_2 = require("../../../rtp/src");
const const_2 = require("../../../rtp/src/srtp/const");
const utils_1 = require("../utils");
const log = debug_1.default("werift:packages/webrtc/src/transport/dtls.ts");
class RTCDtlsTransport {
    constructor(iceTransport, router, certificates, srtpProfiles = []) {
        this.iceTransport = iceTransport;
        this.router = router;
        this.certificates = certificates;
        this.srtpProfiles = srtpProfiles;
        this.state = "new";
        this.role = "auto";
        this.srtpStarted = false;
        this.transportSequenceNumber = 0;
        this.dataReceiver = () => { };
        this.onStateChange = new rx_mini_1.default();
        this.localCertificate = this.certificates[0];
        this.sendData = async (data) => {
            if (!this.dtls)
                throw new Error("dtls not established");
            await this.dtls.send(data);
        };
    }
    get localParameters() {
        return new RTCDtlsParameters(this.localCertificate ? this.localCertificate.getFingerprints() : [], this.role);
    }
    async setupCertificate() {
        if (!this.localCertificate) {
            const { certPem, keyPem, signatureHash } = await cipher_1.CipherContext.createSelfSignedCertificateWithKey({
                signature: const_1.SignatureAlgorithm.ecdsa,
                hash: const_1.HashAlgorithm.sha256,
            }, const_1.NamedCurveAlgorithm.secp256r1);
            this.localCertificate = new RTCCertificate(keyPem, certPem, signatureHash);
        }
    }
    setRemoteParams(remoteParameters) {
        this.remoteParameters = remoteParameters;
    }
    async start() {
        if (this.state !== "new")
            throw new Error();
        if (this.remoteParameters?.fingerprints.length === 0)
            throw new Error();
        if (this.role === "auto") {
            if (this.iceTransport.role === "controlling") {
                this.role = "server";
            }
            else {
                this.role = "client";
            }
        }
        this.setState("connecting");
        await new Promise(async (r) => {
            if (this.role === "server") {
                this.dtls = new src_1.DtlsServer({
                    cert: this.localCertificate?.certPem,
                    key: this.localCertificate?.privateKey,
                    signatureHash: this.localCertificate?.signatureHash,
                    transport: createIceTransport(this.iceTransport.connection),
                    srtpProfiles: this.srtpProfiles,
                    extendedMasterSecret: true,
                });
            }
            else {
                this.dtls = new src_1.DtlsClient({
                    cert: this.localCertificate?.certPem,
                    key: this.localCertificate?.privateKey,
                    signatureHash: this.localCertificate?.signatureHash,
                    transport: createIceTransport(this.iceTransport.connection),
                    srtpProfiles: this.srtpProfiles,
                    extendedMasterSecret: true,
                });
            }
            this.dtls.onData.subscribe((buf) => {
                this.dataReceiver(buf);
            });
            this.dtls.onClose.once(() => {
                this.setState("closed");
            });
            this.dtls.onConnect.once(r);
            this.dtls.onError.once((error) => {
                this.setState("failed");
                log("dtls failed", error);
            });
            if (this.dtls instanceof src_1.DtlsClient) {
                await promises_1.setTimeout(100);
                this.dtls.connect().catch((error) => {
                    this.setState("failed");
                    log("dtls connect failed", error);
                });
            }
        });
        if (this.srtpProfiles.length > 0) {
            this.startSrtp();
        }
        this.setState("connected");
        log("dtls connected");
    }
    startSrtp() {
        if (!this.dtls)
            throw new Error();
        if (this.srtpStarted)
            return;
        this.srtpStarted = true;
        const profile = this.dtls.srtp.srtpProfile;
        if (!profile) {
            throw new Error("need srtpProfile");
        }
        log("selected SRTP Profile", profile);
        const { localKey, localSalt, remoteKey, remoteSalt } = this.dtls.extractSessionKeys(const_2.keyLength(profile), const_2.saltLength(profile));
        const config = {
            keys: {
                localMasterKey: localKey,
                localMasterSalt: localSalt,
                remoteMasterKey: remoteKey,
                remoteMasterSalt: remoteSalt,
            },
            profile,
        };
        this.srtp = new src_2.SrtpSession(config);
        this.srtcp = new src_2.SrtcpSession(config);
        this.iceTransport.connection.onData.subscribe((data) => {
            if (!utils_1.isMedia(data))
                return;
            if (utils_1.isRtcp(data)) {
                const dec = this.srtcp.decrypt(data);
                const rtcps = src_2.RtcpPacketConverter.deSerialize(dec);
                rtcps.forEach((rtcp) => this.router.routeRtcp(rtcp));
            }
            else {
                const dec = this.srtp.decrypt(data);
                const rtp = src_2.RtpPacket.deSerialize(dec);
                this.router.routeRtp(rtp);
            }
        });
    }
    sendRtp(payload, header) {
        const enc = this.srtp.encrypt(payload, header);
        this.iceTransport.connection.send(enc);
        return enc.length;
    }
    async sendRtcp(packets) {
        const payload = Buffer.concat(packets.map((packet) => packet.serialize()));
        const enc = this.srtcp.encrypt(payload);
        try {
            await this.iceTransport.connection.send(enc);
        }
        catch (error) {
            throw new Error("ice");
        }
    }
    setState(state) {
        if (state != this.state) {
            this.state = state;
            this.onStateChange.execute(state);
        }
    }
    async stop() {
        this.setState("closed");
        // todo impl send alert
    }
}
exports.RTCDtlsTransport = RTCDtlsTransport;
exports.DtlsStates = [
    "new",
    "connecting",
    "connected",
    "closed",
    "failed",
];
class RTCCertificate {
    constructor(privateKeyPem, certPem, signatureHash) {
        this.certPem = certPem;
        this.signatureHash = signatureHash;
        const cert = x509_1.Certificate.fromPEM(Buffer.from(certPem));
        this.publicKey = cert.publicKey.toPEM();
        this.privateKey = x509_1.PrivateKey.fromPEM(Buffer.from(privateKeyPem)).toPEM();
    }
    getFingerprints() {
        return [
            new RTCDtlsFingerprint("sha-256", utils_1.fingerprint(x509_1.Certificate.fromPEM(Buffer.from(this.certPem)).raw, "sha256")),
        ];
    }
}
exports.RTCCertificate = RTCCertificate;
class RTCDtlsFingerprint {
    constructor(algorithm, value) {
        this.algorithm = algorithm;
        this.value = value;
    }
}
exports.RTCDtlsFingerprint = RTCDtlsFingerprint;
class RTCDtlsParameters {
    constructor(fingerprints = [], role) {
        this.fingerprints = fingerprints;
        this.role = role;
    }
}
exports.RTCDtlsParameters = RTCDtlsParameters;
class IceTransport {
    constructor(ice) {
        this.ice = ice;
        this.send = this.ice.send;
        ice.onData.subscribe((buf) => {
            if (utils_1.isDtls(buf)) {
                if (this.onData)
                    this.onData(buf);
            }
        });
    }
    close() {
        this.ice.close();
    }
}
const createIceTransport = (ice) => new IceTransport(ice);
//# sourceMappingURL=dtls.js.map