import Event from "rx.mini";
import { RTCDtlsTransport } from "../transport/dtls";
import { Kind } from "../types/domain";
import { RTCRtpCodecParameters, RTCRtpHeaderExtensionParameters } from "./parameters";
import { RTCRtpReceiver } from "./rtpReceiver";
import { RTCRtpSender } from "./rtpSender";
import { MediaStreamTrack } from "./track";
export declare class RTCRtpTransceiver {
    readonly kind: Kind;
    readonly receiver: RTCRtpReceiver;
    readonly sender: RTCRtpSender;
    /**RFC 8829 4.2.4.  direction the transceiver was initialized with */
    direction: Direction;
    dtlsTransport: RTCDtlsTransport;
    readonly uuid: string;
    readonly onTrack: Event<[MediaStreamTrack]>;
    mid?: string;
    mLineIndex?: number;
    usedForSender: boolean;
    private _currentDirection?;
    set currentDirection(direction: Direction | "stopped" | undefined);
    /**RFC 8829 4.2.5. last negotiated direction */
    get currentDirection(): Direction | "stopped" | undefined;
    offerDirection: Direction;
    codecs: RTCRtpCodecParameters[];
    headerExtensions: RTCRtpHeaderExtensionParameters[];
    options: Partial<TransceiverOptions>;
    stopping: boolean;
    stopped: boolean;
    constructor(kind: Kind, receiver: RTCRtpReceiver, sender: RTCRtpSender, 
    /**RFC 8829 4.2.4.  direction the transceiver was initialized with */
    direction: Direction, dtlsTransport: RTCDtlsTransport);
    get msid(): string;
    addTrack(track: MediaStreamTrack): void;
    stop(): void;
}
export declare const Directions: readonly ["inactive", "sendonly", "recvonly", "sendrecv"];
export declare type Direction = typeof Directions[number];
declare type SimulcastDirection = "send" | "recv";
export interface TransceiverOptions {
    direction: Direction;
    simulcast: {
        direction: SimulcastDirection;
        rid: string;
    }[];
}
export {};
