"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unwrapRtx = exports.RTCRtpReceiver = void 0;
const debug_1 = require("debug");
const jspack_1 = require("jspack");
const promises_1 = require("timers/promises");
const uuid_1 = require("uuid");
const src_1 = require("../../../common/src");
const src_2 = require("../../../rtp/src");
const rtpExtension_1 = require("../extension/rtpExtension");
const nack_1 = require("./nack");
const receiverTwcc_1 = require("./receiver/receiverTwcc");
const statistics_1 = require("./statistics");
const log = debug_1.debug("werift:packages/webrtc/src/media/rtpReceiver.ts");
class RTCRtpReceiver {
    constructor(kind, dtlsTransport, rtcpSsrc) {
        this.kind = kind;
        this.dtlsTransport = dtlsTransport;
        this.rtcpSsrc = rtcpSsrc;
        this.codecs = {};
        this.ssrcByRtx = {};
        this.nack = new nack_1.Nack(this);
        this.type = "receiver";
        this.uuid = uuid_1.v4();
        this.tracks = [];
        this.trackBySSRC = {};
        this.trackByRID = {};
        // last senderReport
        this.lsr = {};
        this.lsrTime = {};
        this.onPacketLost = this.nack.onPacketLost;
        this.supportTWCC = false;
        this.stopped = false;
        this.rtcpRunning = false;
        this.rtcpCancel = new AbortController();
        this.remoteStreams = {};
        this.handleRtpBySsrc = (packet, extensions) => {
            const track = this.trackBySSRC[packet.header.ssrc];
            this.handleRTP(packet, extensions, track);
        };
        this.handleRtpByRid = (packet, rid, extensions) => {
            const track = this.trackByRID[rid];
            if (!this.trackBySSRC[packet.header.ssrc]) {
                this.trackBySSRC[packet.header.ssrc] = track;
            }
            this.handleRTP(packet, extensions, track);
        };
    }
    // todo fix
    get track() {
        return this.tracks[0];
    }
    prepareReceive(params) {
        params.codecs.forEach((c) => {
            this.codecs[c.payloadType] = c;
        });
        params.encodings.forEach((e) => {
            if (e.rtx) {
                this.ssrcByRtx[e.rtx.ssrc] = e.ssrc;
            }
        });
    }
    /**
     * setup TWCC if supported
     */
    setupTWCC(mediaSourceSsrc) {
        this.supportTWCC = !!Object.values(this.codecs).find((codec) => codec.rtcpFeedback.find((v) => v.type === "transport-cc"));
        log("twcc support", this.supportTWCC);
        if (this.supportTWCC && mediaSourceSsrc) {
            this.receiverTWCC = new receiverTwcc_1.ReceiverTWCC(this.dtlsTransport, this.rtcpSsrc, mediaSourceSsrc);
        }
    }
    addTrack(track) {
        const exist = this.tracks.find((t) => {
            if (t.rid)
                return t.rid === track.rid;
            if (t.ssrc)
                return t.ssrc === track.ssrc;
        });
        if (exist)
            return false;
        this.tracks.push(track);
        if (track.ssrc)
            this.trackBySSRC[track.ssrc] = track;
        if (track.rid)
            this.trackByRID[track.rid] = track;
        return true;
    }
    stop() {
        this.stopped = true;
        this.rtcpRunning = false;
        this.rtcpCancel.abort();
        if (this.receiverTWCC)
            this.receiverTWCC.twccRunning = false;
        this.nack.close();
    }
    async runRtcp() {
        if (this.rtcpRunning || this.stopped)
            return;
        this.rtcpRunning = true;
        try {
            while (this.rtcpRunning) {
                await promises_1.setTimeout(500 + Math.random() * 1000, undefined, {
                    signal: this.rtcpCancel.signal,
                });
                const reports = Object.entries(this.remoteStreams).map(([ssrc, stream]) => {
                    let lsr = 0n, dlsr = 0;
                    if (this.lsr[ssrc]) {
                        lsr = this.lsr[ssrc];
                        const delay = Date.now() / 1000 - this.lsrTime[ssrc];
                        if (delay > 0 && delay < 65536) {
                            dlsr = src_1.int(delay * 65536);
                        }
                    }
                    return new src_2.RtcpReceiverInfo({
                        ssrc: Number(ssrc),
                        fractionLost: stream.fraction_lost,
                        packetsLost: stream.packets_lost,
                        highestSequence: stream.max_seq,
                        jitter: stream.jitter,
                        lsr: Number(lsr),
                        dlsr,
                    });
                });
                const packet = new src_2.RtcpRrPacket({ ssrc: this.rtcpSsrc, reports });
                try {
                    await this.dtlsTransport.sendRtcp([packet]);
                }
                catch (error) {
                    log("sendRtcp failed", error);
                    await promises_1.setTimeout(500 + Math.random() * 1000);
                }
            }
        }
        catch (error) { }
    }
    /**todo impl */
    getStats() { }
    async sendRtcpPLI(mediaSsrc) {
        const packet = new src_2.RtcpPayloadSpecificFeedback({
            feedback: new src_2.PictureLossIndication({
                senderSsrc: this.rtcpSsrc,
                mediaSsrc,
            }),
        });
        try {
            await this.dtlsTransport.sendRtcp([packet]);
        }
        catch (error) {
            log(error);
        }
    }
    handleRtcpPacket(packet) {
        switch (packet.type) {
            case src_2.RtcpSrPacket.type:
                {
                    const sr = packet;
                    this.lsr[sr.ssrc] = (sr.senderInfo.ntpTimestamp >> 16n) & 0xffffffffn;
                    this.lsrTime[sr.ssrc] = Date.now() / 1000;
                }
                break;
        }
    }
    handleRTP(packet, extensions, track) {
        if (this.stopped)
            return;
        const codec = this.codecs[packet.header.payloadType];
        if (!codec) {
            log("unknown codec " + packet.header.payloadType);
            return;
        }
        this.remoteStreams[packet.header.ssrc] =
            this.remoteStreams[packet.header.ssrc] ??
                new statistics_1.StreamStatistics(codec.clockRate);
        this.remoteStreams[packet.header.ssrc].add(packet);
        if (this.receiverTWCC) {
            const transportSequenceNumber = extensions[rtpExtension_1.RTP_EXTENSION_URI.transportWideCC];
            if (!transportSequenceNumber == undefined) {
                throw new Error("undefined");
            }
            this.receiverTWCC.handleTWCC(transportSequenceNumber);
        }
        else if (this.supportTWCC) {
            this.setupTWCC(packet.header.ssrc);
        }
        if (codec.name.toLowerCase() === "rtx") {
            const originalSsrc = this.ssrcByRtx[packet.header.ssrc];
            const rtxCodec = this.codecs[codec.parameters["apt"]];
            if (packet.payload.length < 2)
                return;
            packet = unwrapRtx(packet, rtxCodec.payloadType, originalSsrc);
            track = this.trackBySSRC[originalSsrc];
        }
        // todo fix select use or not use nack
        if (track?.kind === "video")
            this.nack.addPacket(packet);
        if (track)
            track.onReceiveRtp.execute(packet.clone());
        this.runRtcp();
    }
}
exports.RTCRtpReceiver = RTCRtpReceiver;
function unwrapRtx(rtx, payloadType, ssrc) {
    const packet = new src_2.RtpPacket(new src_2.RtpHeader({
        payloadType,
        marker: rtx.header.marker,
        sequenceNumber: jspack_1.jspack.Unpack("!H", rtx.payload.slice(0, 2))[0],
        timestamp: rtx.header.timestamp,
        ssrc,
    }), rtx.payload.slice(2));
    return packet;
}
exports.unwrapRtx = unwrapRtx;
//# sourceMappingURL=rtpReceiver.js.map