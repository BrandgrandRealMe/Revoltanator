"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapRtx = exports.RTCRtpSender = void 0;
const crypto_1 = require("crypto");
const debug_1 = __importDefault(require("debug"));
const jspack_1 = require("jspack");
const rx_mini_1 = __importDefault(require("rx.mini"));
const promises_1 = require("timers/promises");
const uuid = __importStar(require("uuid"));
const src_1 = require("../../../common/src");
const src_2 = require("../../../rtp/src");
const rtpExtension_1 = require("../extension/rtpExtension");
const utils_1 = require("../utils");
const senderBWE_1 = require("./senderBWE/senderBWE");
const track_1 = require("./track");
const log = debug_1.default("werift:packages/webrtc/src/media/rtpSender.ts");
const RTP_HISTORY_SIZE = 128;
const RTT_ALPHA = 0.85;
class RTCRtpSender {
    constructor(trackOrKind, dtlsTransport) {
        this.trackOrKind = trackOrKind;
        this.dtlsTransport = dtlsTransport;
        this.type = "sender";
        this.kind = typeof this.trackOrKind === "string"
            ? this.trackOrKind
            : this.trackOrKind.kind;
        this.ssrc = jspack_1.jspack.Unpack("!L", crypto_1.randomBytes(4))[0];
        this.rtxSsrc = jspack_1.jspack.Unpack("!L", crypto_1.randomBytes(4))[0];
        this.streamId = uuid.v4();
        this.trackId = uuid.v4();
        this.onReady = new rx_mini_1.default();
        this.onRtcp = new rx_mini_1.default();
        this.onPictureLossIndication = new rx_mini_1.default();
        this.onGenericNack = new rx_mini_1.default();
        this.senderBWE = new senderBWE_1.SenderBandwidthEstimator();
        this.rtxSequenceNumber = src_1.random16();
        this.headerExtensions = [];
        this.lsrTime = Date.now() / 1000;
        this.ntpTimestamp = 0n;
        this.rtpTimestamp = 0;
        this.octetCount = 0;
        this.packetCount = 0;
        this.receiverEstimatedMaxBitrate = 0n;
        this.timestampOffset = 0;
        this.seqOffset = 0;
        this.rtpCache = [];
        this.stopped = false;
        this.rtcpRunning = false;
        this.rtcpCancel = new AbortController();
        dtlsTransport.onStateChange.subscribe((state) => {
            if (state === "connected") {
                this.onReady.execute();
            }
        });
        if (trackOrKind instanceof track_1.MediaStreamTrack) {
            this.registerTrack(trackOrKind);
        }
    }
    prepareSend(params) {
        this.cname = params.rtcp?.cname;
        this.mid = params.muxId;
        this.headerExtensions = params.headerExtensions;
        this.rtpStreamId = params.rtpStreamId;
        this.repairedRtpStreamId = params.repairedRtpStreamId;
        for (const codec of params.codecs) {
            if (codec.name.toLowerCase() === "rtx" &&
                codec.parameters["apt"] === params.codecs[0].payloadType) {
                this.rtxPayloadType = codec.payloadType;
                break;
            }
        }
        this.codec = params.codecs[0];
        if (this.track) {
            this.track.codec = this.codec;
        }
    }
    registerTrack(track) {
        if (track.stopped)
            throw new Error("track is ended");
        if (this.disposeTrack) {
            this.disposeTrack();
        }
        track.id = this.trackId;
        const { unSubscribe } = track.onReceiveRtp.subscribe((rtp) => {
            this.sendRtp(rtp);
        });
        this.track = track;
        this.disposeTrack = unSubscribe;
        if (this.codec) {
            track.codec = this.codec;
        }
    }
    async replaceTrack(track) {
        if (track === null) {
            // todo impl
            return;
        }
        if (track.stopped)
            throw new Error("track is ended");
        if (this.sequenceNumber != undefined) {
            const header = track.header || (await track.onReceiveRtp.asPromise())[0].header;
            this.replaceRTP(header);
        }
        this.registerTrack(track);
        log("replaceTrack", "ssrc", track.ssrc, "rid", track.rid);
    }
    stop() {
        this.stopped = true;
        this.rtcpRunning = false;
        this.rtcpCancel.abort();
        this.track = undefined;
    }
    async runRtcp() {
        if (this.rtcpRunning || this.stopped)
            return;
        this.rtcpRunning = true;
        try {
            while (this.rtcpRunning) {
                await promises_1.setTimeout(500 + Math.random() * 1000, undefined, {
                    signal: this.rtcpCancel.signal,
                });
                const packets = [
                    new src_2.RtcpSrPacket({
                        ssrc: this.ssrc,
                        senderInfo: new src_2.RtcpSenderInfo({
                            ntpTimestamp: this.ntpTimestamp,
                            rtpTimestamp: this.rtpTimestamp,
                            packetCount: this.packetCount,
                            octetCount: this.octetCount,
                        }),
                    }),
                ];
                this.lsr = (this.ntpTimestamp >> 16n) & 0xffffffffn;
                this.lsrTime = Date.now() / 1000;
                if (this.cname) {
                    packets.push(new src_2.RtcpSourceDescriptionPacket({
                        chunks: [
                            new src_2.SourceDescriptionChunk({
                                source: this.ssrc,
                                items: [
                                    new src_2.SourceDescriptionItem({ type: 1, text: this.cname }),
                                ],
                            }),
                        ],
                    }));
                }
                try {
                    await this.dtlsTransport.sendRtcp(packets);
                }
                catch (error) {
                    log("sendRtcp failed", error);
                    await promises_1.setTimeout(500 + Math.random() * 1000);
                }
            }
        }
        catch (error) { }
    }
    replaceRTP({ sequenceNumber, timestamp }) {
        if (this.sequenceNumber != undefined) {
            this.seqOffset = src_1.uint16Add(this.sequenceNumber, -sequenceNumber);
        }
        if (this.timestamp != undefined) {
            this.timestampOffset = Number(src_1.uint32Add(BigInt(this.timestamp), BigInt(-timestamp)));
        }
        this.rtpCache = [];
        log("replaceRTP", this.sequenceNumber, sequenceNumber, this.seqOffset);
    }
    sendRtp(rtp) {
        if (this.dtlsTransport.state !== "connected" || !this.codec) {
            return;
        }
        rtp = Buffer.isBuffer(rtp) ? src_2.RtpPacket.deSerialize(rtp) : rtp;
        const header = rtp.header;
        header.ssrc = this.ssrc;
        header.payloadType = this.codec.payloadType;
        header.timestamp = Number(src_1.uint32Add(BigInt(header.timestamp), BigInt(this.timestampOffset)));
        header.sequenceNumber = src_1.uint16Add(header.sequenceNumber, this.seqOffset);
        this.timestamp = header.timestamp;
        this.sequenceNumber = header.sequenceNumber;
        header.extensions = this.headerExtensions
            .map((extension) => {
            const payload = (() => {
                switch (extension.uri) {
                    case rtpExtension_1.RTP_EXTENSION_URI.sdesMid:
                        if (this.mid) {
                            return Buffer.from(this.mid);
                        }
                        return;
                    // todo : sender simulcast unsupported now
                    case rtpExtension_1.RTP_EXTENSION_URI.sdesRTPStreamID:
                        if (this.rtpStreamId) {
                            return Buffer.from(this.rtpStreamId);
                        }
                        return;
                    // todo : sender simulcast unsupported now
                    case rtpExtension_1.RTP_EXTENSION_URI.repairedRtpStreamId:
                        if (this.repairedRtpStreamId) {
                            return Buffer.from(this.repairedRtpStreamId);
                        }
                        return;
                    case rtpExtension_1.RTP_EXTENSION_URI.transportWideCC:
                        this.dtlsTransport.transportSequenceNumber = src_1.uint16Add(this.dtlsTransport.transportSequenceNumber, 1);
                        return src_1.bufferWriter([2], [this.dtlsTransport.transportSequenceNumber]);
                    case rtpExtension_1.RTP_EXTENSION_URI.absSendTime:
                        const buf = Buffer.alloc(3);
                        const time = (utils_1.ntpTime() >> 14n) & 0x00ffffffn;
                        buf.writeUIntBE(Number(time), 0, 3);
                        return buf;
                }
            })();
            if (payload)
                return { id: extension.id, payload };
        })
            .filter((v) => v);
        this.ntpTimestamp = utils_1.ntpTime();
        this.rtpTimestamp = rtp.header.timestamp;
        this.octetCount += rtp.payload.length;
        this.packetCount = Number(src_1.uint32Add(BigInt(this.packetCount), 1n));
        rtp.header = header;
        this.rtpCache.push(rtp);
        this.rtpCache = this.rtpCache.slice(-RTP_HISTORY_SIZE);
        const size = this.dtlsTransport.sendRtp(rtp.payload, header);
        this.runRtcp();
        const sentInfo = {
            wideSeq: this.dtlsTransport.transportSequenceNumber,
            size,
            sendingAtMs: utils_1.milliTime(),
            sentAtMs: utils_1.milliTime(),
        };
        this.senderBWE.rtpPacketSent(sentInfo);
    }
    handleRtcpPacket(rtcpPacket) {
        switch (rtcpPacket.type) {
            case src_2.RtcpSrPacket.type:
            case src_2.RtcpRrPacket.type:
                {
                    const packet = rtcpPacket;
                    packet.reports
                        .filter((report) => report.ssrc === this.ssrc)
                        .forEach((report) => {
                        if (this.lsr === BigInt(report.lsr) && report.dlsr) {
                            const rtt = Date.now() / 1000 - this.lsrTime - report.dlsr / 65536;
                            if (this.rtt === undefined) {
                                this.rtt = rtt;
                            }
                            else {
                                this.rtt = RTT_ALPHA * this.rtt + (1 - RTT_ALPHA) * rtt;
                            }
                        }
                    });
                }
                break;
            case src_2.RtcpTransportLayerFeedback.type:
                {
                    const packet = rtcpPacket;
                    switch (packet.feedback.count) {
                        case src_2.TransportWideCC.count:
                            {
                                const feedback = packet.feedback;
                                this.senderBWE.receiveTWCC(feedback);
                            }
                            break;
                        case src_2.GenericNack.count:
                            {
                                const feedback = packet.feedback;
                                feedback.lost.forEach((seqNum) => {
                                    let packet = this.rtpCache.find((rtp) => rtp.header.sequenceNumber === seqNum);
                                    if (packet) {
                                        if (this.rtxPayloadType != undefined) {
                                            packet = wrapRtx(packet, this.rtxPayloadType, this.rtxSequenceNumber, this.rtxSsrc);
                                            this.rtxSequenceNumber = src_1.uint16Add(this.rtxSequenceNumber, 1);
                                        }
                                        this.dtlsTransport.sendRtp(packet.payload, packet.header);
                                    }
                                });
                                this.onGenericNack.execute(feedback);
                            }
                            break;
                    }
                }
                break;
            case src_2.RtcpPayloadSpecificFeedback.type:
                {
                    const packet = rtcpPacket;
                    switch (packet.feedback.count) {
                        case src_2.ReceiverEstimatedMaxBitrate.count:
                            {
                                const feedback = packet.feedback;
                                this.receiverEstimatedMaxBitrate = feedback.bitrate;
                            }
                            break;
                        case src_2.PictureLossIndication.count:
                            {
                                this.onPictureLossIndication.execute();
                            }
                            break;
                    }
                }
                break;
        }
        this.onRtcp.execute(rtcpPacket);
    }
}
exports.RTCRtpSender = RTCRtpSender;
function wrapRtx(packet, payloadType, sequenceNumber, ssrc) {
    const rtx = new src_2.RtpPacket(new src_2.RtpHeader({
        payloadType,
        marker: packet.header.marker,
        sequenceNumber,
        timestamp: packet.header.timestamp,
        ssrc,
        csrc: packet.header.csrc,
        extensions: packet.header.extensions,
    }), Buffer.concat([
        Buffer.from(jspack_1.jspack.Pack("!H", [packet.header.sequenceNumber])),
        packet.payload,
    ]));
    return rtx;
}
exports.wrapRtx = wrapRtx;
//# sourceMappingURL=rtpSender.js.map