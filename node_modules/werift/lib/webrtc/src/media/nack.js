"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Nack = void 0;
const lodash_1 = require("lodash");
const rx_mini_1 = __importDefault(require("rx.mini"));
const src_1 = require("../../../common/src");
const src_2 = require("../../../rtp/src");
const LOST_SIZE = 30 * 5;
class Nack {
    constructor(receiver) {
        this.receiver = receiver;
        this.newEstSeqNum = 0;
        this._lost = {};
        this.nackLoop = setInterval(() => this.packetLost(), 20);
        this.onPacketLost = new rx_mini_1.default();
    }
    get lost() {
        return Object.keys(this._lost).map(Number);
    }
    addPacket(packet) {
        const { sequenceNumber, ssrc } = packet.header;
        this.mediaSourceSsrc = ssrc;
        if (this.newEstSeqNum === 0) {
            this.newEstSeqNum = sequenceNumber;
            return;
        }
        if (this._lost[sequenceNumber]) {
            delete this._lost[sequenceNumber];
            return;
        }
        if (sequenceNumber === src_1.uint16Add(this.newEstSeqNum, 1)) {
            this.newEstSeqNum = sequenceNumber;
        }
        else if (sequenceNumber > src_1.uint16Add(this.newEstSeqNum, 1)) {
            // packet lost detected
            lodash_1.range(src_1.uint16Add(this.newEstSeqNum, 1), sequenceNumber).forEach((seq) => {
                this._lost[seq] = 1;
            });
            this.receiver.sendRtcpPLI(this.mediaSourceSsrc);
            this.newEstSeqNum = sequenceNumber;
            if (Object.keys(this._lost).length > LOST_SIZE) {
                this._lost = Object.entries(this._lost)
                    .slice(-LOST_SIZE)
                    .reduce((acc, [key, v]) => {
                    acc[key] = v;
                    return acc;
                }, {});
            }
        }
    }
    close() {
        clearInterval(this.nackLoop);
    }
    increment() {
        Object.keys(this._lost).forEach((seq) => {
            if (++this._lost[seq] > 10) {
                delete this._lost[seq];
            }
        });
    }
    packetLost() {
        if (this.lost.length > 0 && this.mediaSourceSsrc) {
            const nack = new src_2.GenericNack({
                senderSsrc: this.receiver.rtcpSsrc,
                mediaSourceSsrc: this.mediaSourceSsrc,
                lost: this.lost,
            });
            const rtcp = new src_2.RtcpTransportLayerFeedback({
                feedback: nack,
            });
            this.receiver.dtlsTransport.sendRtcp([rtcp]);
            this.increment();
            this.onPacketLost.execute(nack);
        }
    }
}
exports.Nack = Nack;
//# sourceMappingURL=nack.js.map