"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DtlsContext = void 0;
const debug_1 = require("debug");
const log = debug_1.debug("werift-dtls : packages/dtls/src/context/dtls.ts : log");
class DtlsContext {
    constructor(options, sessionType) {
        this.options = options;
        this.sessionType = sessionType;
        this.version = { major: 255 - 1, minor: 255 - 2 };
        this.lastFlight = [];
        this.lastMessage = [];
        this.recordSequenceNumber = 0;
        this.sequenceNumber = 0;
        this.epoch = 0;
        this.flight = 0;
        this.handshakeCache = {};
        this.requestedCertificateTypes = [];
        this.requestedSignatureAlgorithms = [];
        this.remoteExtendedMasterSecret = false;
        this.checkHandshakesExist = (handshakes) => !handshakes.find((type) => this.sortedHandshakeCache.find((h) => h.msg_type === type) == undefined);
    }
    get sessionId() {
        return this.cookie ? this.cookie.toString("hex").slice(0, 10) : "";
    }
    get sortedHandshakeCache() {
        return Object.entries(this.handshakeCache)
            .sort(([a], [b]) => Number(a) - Number(b))
            .map(([, { data }]) => data.sort((a, b) => a.message_seq - b.message_seq))
            .flatMap((v) => v);
    }
    bufferHandshakeCache(handshakes, isLocal, flight) {
        if (!this.handshakeCache[flight]) {
            this.handshakeCache[flight] = { data: [], isLocal, flight };
        }
        const filtered = handshakes.filter((h) => {
            const exist = this.handshakeCache[flight].data.find((t) => t.msg_type === h.msg_type);
            if (exist) {
                log(this.sessionId, "exist", exist.summary, isLocal, flight);
                return false;
            }
            return true;
        });
        this.handshakeCache[flight].data = [
            ...this.handshakeCache[flight].data,
            ...filtered,
        ];
    }
}
exports.DtlsContext = DtlsContext;
//# sourceMappingURL=dtls.js.map