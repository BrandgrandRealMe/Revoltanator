{"version":3,"file":"fragment.js","sourceRoot":"","sources":["../../../../../../dtls/src/record/message/fragment.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport { decode, encode, types } from \"binary-data\";\n\nimport { HandshakeType } from \"../../handshake/const\";\nimport { getObjectSummary } from \"../../helper\";\n\nexport class FragmentedHandshake {\n  static readonly spec = {\n    msg_type: types.uint8,\n    length: types.uint24be,\n    message_seq: types.uint16be,\n    fragment_offset: types.uint24be,\n    fragment_length: types.uint24be,\n    fragment: types.buffer((context: any) => context.current.fragment_length),\n  };\n\n  constructor(\n    public msg_type: number,\n    public length: number,\n    public message_seq: number,\n    public fragment_offset: number,\n    public fragment_length: number,\n    public fragment: Buffer\n  ) {}\n\n  get summary() {\n    return getObjectSummary(this);\n  }\n\n  static createEmpty() {\n    return new FragmentedHandshake(\n      undefined as any,\n      undefined as any,\n      undefined as any,\n      undefined as any,\n      undefined as any,\n      undefined as any\n    );\n  }\n\n  static deSerialize(buf: Buffer) {\n    return new FragmentedHandshake(\n      //@ts-ignore\n      ...Object.values(decode(buf, FragmentedHandshake.spec))\n    );\n  }\n\n  serialize() {\n    const res = encode(this, FragmentedHandshake.spec).slice();\n    return Buffer.from(res);\n  }\n\n  chunk(maxFragmentLength?: number): FragmentedHandshake[] {\n    let start = 0;\n    const totalLength = this.fragment.length;\n\n    if (totalLength === 0)\n      return [\n        new FragmentedHandshake(\n          this.msg_type,\n          totalLength,\n          this.message_seq,\n          start,\n          0,\n          this.fragment\n        ),\n      ];\n\n    const fragments: FragmentedHandshake[] = [];\n    if (!maxFragmentLength) {\n      maxFragmentLength = 1280 - (20 + 8) - (1 + 3 + 2 + 3 + 3);\n    }\n    // loop through the message and fragment it\n    while (start < totalLength) {\n      // calculate maximum length, limited by MTU - IP/UDP headers - handshake overhead\n      const fragmentLength = Math.min(maxFragmentLength, totalLength - start);\n      // slice and dice\n      const data = Buffer.from(\n        this.fragment.slice(start, start + fragmentLength)\n      );\n      if (data.length <= 0) {\n        // this shouldn't happen, but we don't want to introduce an infinite loop\n        throw new Error(\n          `Zero or less bytes processed while fragmenting handshake message.`\n        );\n      }\n      // create the message\n      fragments.push(\n        new FragmentedHandshake(\n          this.msg_type,\n          totalLength,\n          this.message_seq,\n          start,\n          data.length,\n          data\n        )\n      );\n      // step forward by the actual fragment length\n      start += data.length;\n    }\n\n    return fragments;\n  }\n\n  static assemble(messages: FragmentedHandshake[]): FragmentedHandshake {\n    // cannot reassemble empty arrays\n    if (!(messages && messages.length)) {\n      throw new Error(\"cannot reassemble handshake from empty array\");\n    }\n\n    // sort by fragment start\n    messages = messages.sort((a, b) => a.fragment_offset - b.fragment_offset);\n    // combine into a single buffer\n    const combined = Buffer.alloc(messages[0].length);\n    for (const msg of messages) {\n      msg.fragment.copy(combined, msg.fragment_offset);\n    }\n\n    // and return the complete message\n    return new FragmentedHandshake(\n      messages[0].msg_type,\n      messages[0].length,\n      messages[0].message_seq,\n      0,\n      combined.length,\n      combined\n    );\n  }\n\n  static findAllFragments(\n    fragments: FragmentedHandshake[],\n    type: HandshakeType\n  ): FragmentedHandshake[] {\n    const reference = fragments.find((v) => v.msg_type === type);\n    if (!reference) return [];\n\n    // ignore empty arrays\n    if (!(fragments && fragments.length)) return [];\n\n    // return all fragments with matching msg_type, message_seq and total length\n    return fragments.filter((f) => {\n      return (\n        f.msg_type === reference.msg_type &&\n        f.message_seq === reference.message_seq &&\n        f.length === reference.length\n      );\n    });\n  }\n}\n"]}