{"version":3,"file":"flight2.js","sourceRoot":"","sources":["../../../../../../dtls/src/flight/server/flight2.ts"],"names":[],"mappings":"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","sourcesContent":["import { randomBytes } from \"crypto\";\nimport debug from \"debug\";\n\nimport {\n  CipherSuite,\n  NamedCurveAlgorithm,\n  NamedCurveAlgorithms,\n  SignatureAlgorithm,\n} from \"../../cipher/const\";\nimport { generateKeyPair } from \"../../cipher/namedCurve\";\nimport { CipherContext } from \"../../context/cipher\";\nimport { DtlsContext } from \"../../context/dtls\";\nimport { Profile, SrtpContext } from \"../../context/srtp\";\nimport { TransportContext } from \"../../context/transport\";\nimport { EllipticCurves } from \"../../handshake/extensions/ellipticCurves\";\nimport { ExtendedMasterSecret } from \"../../handshake/extensions/extendedMasterSecret\";\nimport { RenegotiationIndication } from \"../../handshake/extensions/renegotiationIndication\";\nimport { Signature } from \"../../handshake/extensions/signature\";\nimport { UseSRTP } from \"../../handshake/extensions/useSrtp\";\nimport { ClientHello } from \"../../handshake/message/client/hello\";\nimport { ServerHelloVerifyRequest } from \"../../handshake/message/server/helloVerifyRequest\";\nimport { DtlsRandom } from \"../../handshake/random\";\nimport { createFragments, createPlaintext } from \"../../record/builder\";\nimport { ContentType } from \"../../record/const\";\n\nconst log = debug(\"werift-dtls : packages/dtls/flight/server/flight2.ts : log\");\n\n// HelloVerifyRequest do not retransmit\n\nexport const flight2 =\n  (\n    udp: TransportContext,\n    dtls: DtlsContext,\n    cipher: CipherContext,\n    srtp: SrtpContext\n  ) =>\n  (clientHello: ClientHello) => {\n    dtls.flight = 2;\n\n    clientHello.extensions.forEach((extension) => {\n      switch (extension.type) {\n        case EllipticCurves.type:\n          {\n            const curves = EllipticCurves.fromData(extension.data).data;\n            log(dtls.sessionId, \"curves\", curves);\n            const curve = curves.find((curve) =>\n              Object.values(NamedCurveAlgorithm).includes(curve as any)\n            ) as NamedCurveAlgorithms;\n            cipher.namedCurve = curve;\n            log(dtls.sessionId, \"curve selected\", cipher.namedCurve);\n          }\n          break;\n        case Signature.type:\n          {\n            if (!cipher.signatureHashAlgorithm)\n              throw new Error(\"need to set certificate\");\n\n            const signatureHash = Signature.fromData(extension.data).data;\n            log(dtls.sessionId, \"hash,signature\", signatureHash);\n            const signature = signatureHash.find(\n              (v) => v.signature === cipher.signatureHashAlgorithm?.signature\n            )?.signature;\n            const hash = signatureHash.find(\n              (v) => v.hash === cipher.signatureHashAlgorithm?.hash\n            )?.hash;\n            if (signature == undefined || hash == undefined)\n              throw new Error(\"invalid signatureHash\");\n          }\n          break;\n        case UseSRTP.type:\n          {\n            if (!dtls.options?.srtpProfiles) return;\n            if (dtls.options.srtpProfiles.length === 0) return;\n\n            const useSrtp = UseSRTP.fromData(extension.data);\n            log(dtls.sessionId, \"srtp profiles\", useSrtp.profiles);\n            const profile = SrtpContext.findMatchingSRTPProfile(\n              useSrtp.profiles as Profile[],\n              dtls.options?.srtpProfiles\n            );\n            if (!profile) {\n              throw new Error();\n            }\n            srtp.srtpProfile = profile;\n            log(dtls.sessionId, \"srtp profile selected\", srtp.srtpProfile);\n          }\n          break;\n        case ExtendedMasterSecret.type:\n          {\n            dtls.remoteExtendedMasterSecret = true;\n          }\n          break;\n        case RenegotiationIndication.type:\n          {\n            log(dtls.sessionId, \"RenegotiationIndication\", extension.data);\n          }\n          break;\n      }\n    });\n\n    cipher.localRandom = new DtlsRandom();\n    cipher.remoteRandom = DtlsRandom.from(clientHello.random);\n\n    const suites = clientHello.cipherSuites;\n    log(dtls.sessionId, \"cipher suites\", suites);\n    const suite = (() => {\n      switch (cipher.signatureHashAlgorithm?.signature) {\n        case SignatureAlgorithm.ecdsa:\n          return CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256;\n        case SignatureAlgorithm.rsa:\n          return CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256;\n      }\n    })();\n    if (suite === undefined || !suites.includes(suite)) {\n      throw new Error(\"dtls cipher suite negotiation failed\");\n    }\n    cipher.cipherSuite = suite;\n    log(dtls.sessionId, \"selected cipherSuite\", cipher.cipherSuite);\n\n    cipher.localKeyPair = generateKeyPair(cipher.namedCurve);\n\n    dtls.cookie = randomBytes(20);\n    const helloVerifyReq = new ServerHelloVerifyRequest(\n      {\n        major: 255 - 1,\n        minor: 255 - 2,\n      },\n      dtls.cookie\n    );\n    const fragments = createFragments(dtls)([helloVerifyReq]);\n    const packets = createPlaintext(dtls)(\n      fragments.map((fragment) => ({\n        type: ContentType.handshake,\n        fragment: fragment.serialize(),\n      })),\n      ++dtls.recordSequenceNumber\n    );\n\n    const buf = packets.map((v) => v.serialize());\n    buf.forEach((v) => udp.send(v));\n  };\n"]}