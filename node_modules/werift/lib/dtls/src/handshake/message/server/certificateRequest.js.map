{"version":3,"file":"certificateRequest.js","sourceRoot":"","sources":["../../../../../../../dtls/src/handshake/message/server/certificateRequest.ts"],"names":[],"mappings":";;;AAAA,6CAAoD;AAGpD,+DAAuE;AAEvE,yCAIsB;AACtB,uCAA4C;AAE5C,8BAA8B;AAE9B,MAAa,wBAAwB;IASnC,YACS,gBAA0B,EAC1B,UAGJ,EACI,WAAqB;QALrB,qBAAgB,GAAhB,gBAAgB,CAAU;QAC1B,eAAU,GAAV,UAAU,CAGd;QACI,gBAAW,GAAX,WAAW,CAAU;QAd9B,YAAO,GAAG,qBAAa,CAAC,sBAAsB,CAAC;IAe5C,CAAC;IAEJ,MAAM,CAAC,WAAW;QAChB,OAAO,IAAI,wBAAwB,CACjC,SAAgB,EAChB,SAAgB,EAChB,SAAgB,CACjB,CAAC;IACJ,CAAC;IAED,MAAM,CAAC,WAAW,CAAC,GAAW;QAC5B,OAAO,IAAI,wBAAwB;QACjC,YAAY;QACZ,GAAG,MAAM,CAAC,MAAM,CAAC,oBAAM,CAAC,GAAG,EAAE,wBAAwB,CAAC,IAAI,CAAC,CAAC,CAC7D,CAAC;IACJ,CAAC;IAED,SAAS;QACP,MAAM,GAAG,GAAG,oBAAM,CAAC,IAAI,EAAE,wBAAwB,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,CAAC;QAChE,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAC1B,CAAC;IAED,UAAU;QACR,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;QAC9B,OAAO,IAAI,8BAAmB,CAC5B,IAAI,CAAC,OAAO,EACZ,IAAI,CAAC,MAAM,EACX,IAAI,CAAC,UAAW,EAChB,CAAC,EACD,IAAI,CAAC,MAAM,EACX,IAAI,CACL,CAAC;IACJ,CAAC;;AAhDH,4DAiDC;AA9CiB,6BAAI,GAAG;IACrB,gBAAgB,EAAE,mBAAK,CAAC,KAAK,CAAC,8BAAqB,EAAE,mBAAK,CAAC,KAAK,EAAE,OAAO,CAAC;IAC1E,UAAU,EAAE,mBAAK,CAAC,KAAK,CAAC,+BAAsB,EAAE,mBAAK,CAAC,QAAQ,EAAE,OAAO,CAAC;IACxE,WAAW,EAAE,mBAAK,CAAC,KAAK,CAAC,0BAAiB,EAAE,mBAAK,CAAC,QAAQ,EAAE,OAAO,CAAC;CACrE,CAAC","sourcesContent":["import { decode, encode, types } from \"binary-data\";\n\nimport { HashAlgorithms, SignatureAlgorithms } from \"../../../cipher/const\";\nimport { FragmentedHandshake } from \"../../../record/message/fragment\";\nimport { Handshake } from \"../../../typings/domain\";\nimport {\n  ClientCertificateType,\n  DistinguishedName,\n  SignatureHashAlgorithm,\n} from \"../../binary\";\nimport { HandshakeType } from \"../../const\";\n\n// 7.4.4.  Certificate Request\n\nexport class ServerCertificateRequest implements Handshake {\n  msgType = HandshakeType.certificate_request_13;\n  messageSeq?: number;\n  static readonly spec = {\n    certificateTypes: types.array(ClientCertificateType, types.uint8, \"bytes\"),\n    signatures: types.array(SignatureHashAlgorithm, types.uint16be, \"bytes\"),\n    authorities: types.array(DistinguishedName, types.uint16be, \"bytes\"),\n  };\n\n  constructor(\n    public certificateTypes: number[],\n    public signatures: {\n      hash: HashAlgorithms;\n      signature: SignatureAlgorithms;\n    }[],\n    public authorities: number[]\n  ) {}\n\n  static createEmpty() {\n    return new ServerCertificateRequest(\n      undefined as any,\n      undefined as any,\n      undefined as any\n    );\n  }\n\n  static deSerialize(buf: Buffer) {\n    return new ServerCertificateRequest(\n      //@ts-ignore\n      ...Object.values(decode(buf, ServerCertificateRequest.spec))\n    );\n  }\n\n  serialize() {\n    const res = encode(this, ServerCertificateRequest.spec).slice();\n    return Buffer.from(res);\n  }\n\n  toFragment() {\n    const body = this.serialize();\n    return new FragmentedHandshake(\n      this.msgType,\n      body.length,\n      this.messageSeq!,\n      0,\n      body.length,\n      body\n    );\n  }\n}\n"]}