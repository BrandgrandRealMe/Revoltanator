{"version":3,"file":"hello.js","sourceRoot":"","sources":["../../../../../../../dtls/src/handshake/message/server/hello.ts"],"names":[],"mappings":";;;AAAA,6CAAoD;AAGpD,+DAAuE;AAEvE,yCAA8D;AAC9D,uCAA4C;AAC5C,yCAA0C;AAE1C,yBAAyB;AAEzB,MAAa,WAAW;IAWtB,YACS,aAAsB,EACtB,MAAc,EACd,SAAiB,EACjB,WAAyB,EACzB,iBAAyB,EACzB,UAAuB;QALvB,kBAAa,GAAb,aAAa,CAAS;QACtB,WAAM,GAAN,MAAM,CAAQ;QACd,cAAS,GAAT,SAAS,CAAQ;QACjB,gBAAW,GAAX,WAAW,CAAc;QACzB,sBAAiB,GAAjB,iBAAiB,CAAQ;QACzB,eAAU,GAAV,UAAU,CAAa;QAhBhC,YAAO,GAAG,qBAAa,CAAC,cAAc,CAAC;IAiBpC,CAAC;IAEJ,MAAM,CAAC,WAAW;QAChB,OAAO,IAAI,WAAW,CACpB,SAAgB,EAChB,SAAgB,EAChB,SAAgB,EAChB,SAAgB,EAChB,SAAgB,EAChB,SAAgB,CACjB,CAAC;IACJ,CAAC;IAED,MAAM,CAAC,WAAW,CAAC,GAAW;QAC5B,MAAM,GAAG,GAAG,oBAAM,CAAC,GAAG,EAAE,WAAW,CAAC,IAAI,CAAC,CAAC;QAC1C,MAAM,GAAG,GAAG,IAAI,WAAW;QACzB,YAAY;QACZ,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CACtB,CAAC;QACF,MAAM,MAAM,GAAG,GAAG,CAAC,SAAS,EAAE,CAAC;QAC/B,IAAI,MAAM,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,EAAE;YAC9B,OAAO,IAAI,WAAW;YACpB,YAAY;YACZ,GAAG,MAAM,CAAC,MAAM,CACd,oBAAM,CAAC,GAAG,EAAE,EAAE,GAAG,WAAW,CAAC,IAAI,EAAE,UAAU,EAAE,sBAAa,EAAE,CAAC,CAChE,CACF,CAAC;SACH;QACD,OAAO,GAAG,CAAC;IACb,CAAC;IAED,SAAS;QACP,MAAM,GAAG,GACP,IAAI,CAAC,UAAU,KAAK,SAAS;YAC3B,CAAC,CAAC,oBAAM,CAAC,IAAI,EAAE,WAAW,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE;YACxC,CAAC,CAAC,oBAAM,CAAC,IAAI,EAAE;gBACX,GAAG,WAAW,CAAC,IAAI;gBACnB,UAAU,EAAE,sBAAa;aAC1B,CAAC,CAAC,KAAK,EAAE,CAAC;QACjB,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAC1B,CAAC;IAED,UAAU;QACR,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;QAC9B,OAAO,IAAI,8BAAmB,CAC5B,IAAI,CAAC,OAAO,EACZ,IAAI,CAAC,MAAM,EACX,IAAI,CAAC,UAAW,EAChB,CAAC,EACD,IAAI,CAAC,MAAM,EACX,IAAI,CACL,CAAC;IACJ,CAAC;;AAtEH,kCAuEC;AApEiB,gBAAI,GAAG;IACrB,aAAa,EAAE,wBAAe;IAC9B,MAAM,EAAE,mBAAU,CAAC,IAAI;IACvB,SAAS,EAAE,mBAAK,CAAC,MAAM,CAAC,mBAAK,CAAC,KAAK,CAAC;IACpC,WAAW,EAAE,mBAAK,CAAC,QAAQ;IAC3B,iBAAiB,EAAE,mBAAK,CAAC,KAAK;CAC/B,CAAC","sourcesContent":["import { decode, encode, types } from \"binary-data\";\n\nimport { CipherSuites } from \"../../../cipher/const\";\nimport { FragmentedHandshake } from \"../../../record/message/fragment\";\nimport { Extension, Handshake, Random, Version } from \"../../../typings/domain\";\nimport { ExtensionList, ProtocolVersion } from \"../../binary\";\nimport { HandshakeType } from \"../../const\";\nimport { DtlsRandom } from \"../../random\";\n\n// 7.4.1.3.  Server Hello\n\nexport class ServerHello implements Handshake {\n  msgType = HandshakeType.server_hello_2;\n  messageSeq?: number;\n  static readonly spec = {\n    serverVersion: ProtocolVersion,\n    random: DtlsRandom.spec,\n    sessionId: types.buffer(types.uint8),\n    cipherSuite: types.uint16be,\n    compressionMethod: types.uint8,\n  };\n\n  constructor(\n    public serverVersion: Version,\n    public random: Random,\n    public sessionId: Buffer,\n    public cipherSuite: CipherSuites,\n    public compressionMethod: number,\n    public extensions: Extension[]\n  ) {}\n\n  static createEmpty() {\n    return new ServerHello(\n      undefined as any,\n      undefined as any,\n      undefined as any,\n      undefined as any,\n      undefined as any,\n      undefined as any\n    );\n  }\n\n  static deSerialize(buf: Buffer) {\n    const res = decode(buf, ServerHello.spec);\n    const cls = new ServerHello(\n      //@ts-ignore\n      ...Object.values(res)\n    );\n    const expect = cls.serialize();\n    if (expect.length < buf.length) {\n      return new ServerHello(\n        //@ts-ignore\n        ...Object.values(\n          decode(buf, { ...ServerHello.spec, extensions: ExtensionList })\n        )\n      );\n    }\n    return cls;\n  }\n\n  serialize() {\n    const res =\n      this.extensions === undefined\n        ? encode(this, ServerHello.spec).slice()\n        : encode(this, {\n            ...ServerHello.spec,\n            extensions: ExtensionList,\n          }).slice();\n    return Buffer.from(res);\n  }\n\n  toFragment() {\n    const body = this.serialize();\n    return new FragmentedHandshake(\n      this.msgType,\n      body.length,\n      this.messageSeq!,\n      0,\n      body.length,\n      body\n    );\n  }\n}\n"]}