"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CipherAesCtr = void 0;
const big_integer_1 = __importDefault(require("big-integer"));
const crypto_1 = require("crypto");
const lodash_1 = require("lodash");
const helper_1 = require("../../helper");
const header_1 = require("../../rtcp/header");
const rtp_1 = require("../../rtp/rtp");
const _1 = require(".");
class CipherAesCtr extends _1.CipherAesBase {
    constructor(srtpSessionKey, srtpSessionSalt, srtcpSessionKey, srtcpSessionSalt, srtpSessionAuthTag, srtcpSessionAuthTag) {
        super(srtpSessionKey, srtpSessionSalt, srtcpSessionKey, srtcpSessionSalt);
        this.srtpSessionAuthTag = srtpSessionAuthTag;
        this.srtcpSessionAuthTag = srtcpSessionAuthTag;
        this.authTagLength = 10;
    }
    encryptRtp(header, payload, rolloverCounter) {
        const dst = Buffer.alloc(header.serializeSize + payload.length + this.authTagLength);
        header.serialize(dst.length).copy(dst);
        const { payloadOffset } = header;
        const counter = this.generateCounter(header.sequenceNumber, rolloverCounter, header.ssrc, this.srtpSessionSalt);
        const cipher = crypto_1.createCipheriv("aes-128-ctr", this.srtpSessionKey, counter);
        const enc = cipher.update(payload);
        enc.copy(dst, payloadOffset);
        const totalLength = payloadOffset + payload.length;
        const authTag = this.generateSrtpAuthTag(dst.slice(0, totalLength), rolloverCounter);
        authTag.copy(dst, totalLength);
        return dst;
    }
    decryptRtp(cipherText, rolloverCounter) {
        const header = rtp_1.RtpHeader.deSerialize(cipherText);
        let dst = Buffer.from([]);
        dst = helper_1.growBufferSize(dst, cipherText.length - this.authTagLength);
        cipherText = cipherText.slice(0, cipherText.length - this.authTagLength);
        cipherText.slice(0, header.payloadOffset).copy(dst);
        const counter = this.generateCounter(header.sequenceNumber, rolloverCounter, header.ssrc, this.srtpSessionSalt);
        const cipher = crypto_1.createDecipheriv("aes-128-ctr", this.srtpSessionKey, counter);
        const payload = cipherText.slice(header.payloadOffset);
        const buf = cipher.update(payload);
        buf.copy(dst, header.payloadOffset);
        return [dst, header];
    }
    encryptRTCP(rtcpPacket, srtcpIndex) {
        let out = Buffer.from(rtcpPacket);
        const ssrc = out.readUInt32BE(4);
        const counter = this.generateCounter(srtcpIndex & 0xffff, srtcpIndex >> 16, ssrc, this.srtcpSessionSalt);
        const cipher = crypto_1.createCipheriv("aes-128-ctr", this.srtcpSessionKey, counter);
        // Encrypt everything after header
        const buf = cipher.update(out.slice(8));
        buf.copy(out, 8);
        out = Buffer.concat([out, Buffer.alloc(4)]);
        out.writeUInt32BE(srtcpIndex, out.length - 4);
        out[out.length - 4] |= 0x80;
        const authTag = this.generateSrtcpAuthTag(out);
        out = Buffer.concat([out, authTag]);
        return out;
    }
    decryptRTCP(encrypted) {
        const header = header_1.RtcpHeader.deSerialize(encrypted);
        const tailOffset = encrypted.length - (this.authTagLength + srtcpIndexSize);
        const out = Buffer.from(encrypted).slice(0, tailOffset);
        const isEncrypted = encrypted[tailOffset] >> 7;
        if (isEncrypted === 0)
            return [out, header];
        let srtcpIndex = encrypted.readUInt32BE(tailOffset);
        srtcpIndex &= ~(1 << 31);
        const ssrc = encrypted.readUInt32BE(4);
        // todo impl compare
        const actualTag = encrypted.slice(encrypted.length - 10);
        const counter = this.generateCounter(srtcpIndex & 0xffff, srtcpIndex >> 16, ssrc, this.srtcpSessionSalt);
        const cipher = crypto_1.createDecipheriv("aes-128-ctr", this.srtcpSessionKey, counter);
        const buf = cipher.update(out.slice(8));
        buf.copy(out, 8);
        return [out, header];
    }
    generateSrtcpAuthTag(buf) {
        const srtcpSessionAuth = crypto_1.createHmac("sha1", this.srtcpSessionAuthTag);
        return srtcpSessionAuth.update(buf).digest().slice(0, 10);
    }
    generateCounter(sequenceNumber, rolloverCounter, ssrc, sessionSalt) {
        const counter = Buffer.alloc(16);
        counter.writeUInt32BE(ssrc, 4);
        counter.writeUInt32BE(rolloverCounter, 8);
        counter.writeUInt32BE(big_integer_1.default(sequenceNumber).shiftLeft(16).toJSNumber(), 12);
        lodash_1.range(sessionSalt.length).forEach((i) => {
            counter[i] = counter[i] ^ sessionSalt[i];
        });
        return counter;
    }
    generateSrtpAuthTag(buf, roc) {
        const srtpSessionAuth = crypto_1.createHmac("sha1", this.srtpSessionAuthTag);
        const rocRaw = Buffer.alloc(4);
        rocRaw.writeUInt32BE(roc);
        return srtpSessionAuth.update(buf).update(rocRaw).digest().slice(0, 10);
    }
}
exports.CipherAesCtr = CipherAesCtr;
const srtcpIndexSize = 4;
//# sourceMappingURL=ctr.js.map