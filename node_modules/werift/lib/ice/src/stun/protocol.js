"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StunProtocol = void 0;
const rx_mini_1 = require("rx.mini");
const transport_1 = require("../transport");
const const_1 = require("./const");
const message_1 = require("./message");
const transaction_1 = require("./transaction");
class StunProtocol {
    constructor(receiver) {
        this.receiver = receiver;
        this.type = "stun";
        this.transactions = {};
        this.closed = new rx_mini_1.Event();
        this.connectionMade = async (useIpv4, portRange) => {
            if (useIpv4) {
                this.transport = await transport_1.UdpTransport.init("udp4", portRange);
            }
            else {
                this.transport = await transport_1.UdpTransport.init("udp6", portRange);
            }
            this.transport.onData = (data, addr) => this.datagramReceived(data, addr);
        };
    }
    get transactionsKeys() {
        return Object.keys(this.transactions);
    }
    connectionLost() {
        this.closed.execute();
        this.closed.complete();
    }
    datagramReceived(data, addr) {
        if (!this.localCandidate)
            throw new Error("not exist");
        const message = message_1.parseMessage(data);
        if (!message) {
            this.receiver.dataReceived(data, this.localCandidate.component);
            return;
        }
        // log("parseMessage", addr, message);
        if ((message.messageClass === const_1.classes.RESPONSE ||
            message.messageClass === const_1.classes.ERROR) &&
            this.transactionsKeys.includes(message.transactionIdHex)) {
            const transaction = this.transactions[message.transactionIdHex];
            transaction.responseReceived(message, addr);
        }
        else if (message.messageClass === const_1.classes.REQUEST) {
            this.receiver.requestReceived(message, addr, this, data);
        }
    }
    getExtraInfo() {
        const { address: host, port } = this.transport.address();
        return [host, port];
    }
    async sendStun(message, addr) {
        const data = message.bytes;
        await this.transport.send(data, addr);
    }
    async sendData(data, addr) {
        await this.transport.send(data, addr);
    }
    async request(request, addr, integrityKey, retransmissions) {
        // """
        // Execute a STUN transaction and return the response.
        // """
        if (this.transactionsKeys.includes(request.transactionIdHex))
            throw new Error("already request ed");
        if (integrityKey) {
            request.addMessageIntegrity(integrityKey);
            request.addFingerprint();
        }
        const transaction = new transaction_1.Transaction(request, addr, this, retransmissions);
        transaction.integrityKey = integrityKey;
        this.transactions[request.transactionIdHex] = transaction;
        try {
            return await transaction.run();
        }
        finally {
            delete this.transactions[request.transactionIdHex];
        }
    }
    async close() {
        Object.values(this.transactions).forEach((transaction) => {
            transaction.cancel();
        });
        await this.transport.close();
    }
}
exports.StunProtocol = StunProtocol;
//# sourceMappingURL=protocol.js.map