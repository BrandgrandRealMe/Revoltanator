"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGlobalIp = exports.findPort = exports.randomPort = void 0;
const dgram_1 = require("dgram");
const ice_1 = require("./ice");
const protocol_1 = require("./stun/protocol");
async function randomPort(protocol = "udp4") {
    const socket = dgram_1.createSocket(protocol);
    setImmediate(() => socket.bind(0));
    await new Promise((r) => {
        socket.once("error", r);
        socket.once("listening", r);
    });
    const port = socket.address()?.port;
    await new Promise((r) => socket.close(() => r()));
    return port;
}
exports.randomPort = randomPort;
async function findPort(min, max, protocol = "udp4") {
    let port;
    for (let i = min; i <= max; i++) {
        const socket = dgram_1.createSocket(protocol);
        setImmediate(() => socket.bind(i));
        await new Promise((r) => {
            socket.once("error", r);
            socket.once("listening", r);
        });
        port = socket.address()?.port;
        await new Promise((r) => socket.close(() => r()));
        if (min <= port && port <= max) {
            break;
        }
    }
    if (!port)
        throw new Error("port not found");
    return port;
}
exports.findPort = findPort;
async function getGlobalIp(stunServer) {
    const connection = new ice_1.Connection(true, {
        stunServer: stunServer ?? ["stun.l.google.com", 19302],
    });
    await connection.gatherCandidates();
    const protocol = new protocol_1.StunProtocol(connection);
    protocol.localCandidate = connection.localCandidates[0];
    await protocol.connectionMade(true);
    const candidate = await ice_1.serverReflexiveCandidate(protocol, [
        "stun.l.google.com",
        19302,
    ]);
    await connection.close();
    await protocol.close();
    return candidate?.host;
}
exports.getGlobalIp = getGlobalIp;
//# sourceMappingURL=utils.js.map