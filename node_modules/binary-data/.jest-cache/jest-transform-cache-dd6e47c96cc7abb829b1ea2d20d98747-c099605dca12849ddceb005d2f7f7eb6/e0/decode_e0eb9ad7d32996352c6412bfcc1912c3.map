{"version":3,"sources":["decode.js"],"names":["jest","mock","reserved","require","when","decode","describe","test","rstream","bytes","res1","res2","schema","a","b","expectedResult","result","expect","toEqual","type1","type2","encode","called","xdecode","rstream_","toBe","context","toHaveProperty","toBeTruthy","expectedError","toThrow","c","buffer","Buffer","alloc"],"mappings":"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","file":"decode.js","sourcesContent":["'use strict';\n\njest.mock('lib/binary-stream');\n\nconst reserved = require('types/reserved');\nconst when = require('types/when');\nconst { decode } = require('lib/decode');\n\ndescribe('decode', () => {\n  test('should use schema', () => {\n    const rstream = {};\n    const bytes = 10;\n\n    const res1 = 100;\n    const res2 = 200;\n\n    const schema = {\n      a: {\n        decode: () => res1,\n      },\n      b: {\n        decode: () => res2,\n      },\n    };\n\n    schema.a.decode.bytes = bytes;\n    schema.b.decode.bytes = bytes;\n\n    const expectedResult = {\n      a: res1,\n      b: res2,\n    };\n\n    const result = decode(rstream, schema);\n    expect(result).toEqual(expectedResult);\n    expect(decode.bytes).toEqual(bytes * 2);\n  });\n\n  test('should skip reserved field', () => {\n    const rstream = {};\n    const bytes = 10;\n    const res1 = 100;\n    const res2 = 200;\n\n    const type1 = {\n      decode: () => res1,\n    };\n\n    const type2 = {\n      decode: () => res2,\n      encode() {},\n    };\n\n    type1.decode.bytes = bytes;\n    type2.decode.bytes = bytes;\n\n    const schema = {\n      a: type1,\n      b: reserved(type2, 1),\n    };\n\n    const expectedResult = {\n      a: res1,\n    };\n\n    const result = decode(rstream, schema);\n    expect(result).toEqual(expectedResult);\n    expect(decode.bytes).toEqual(bytes * 2);\n  });\n\n  test('should set context', () => {\n    const rstream = {};\n    let called = false;\n\n    const schema = {\n      a: {\n        decode: xdecode,\n      },\n    };\n\n    function xdecode(rstream_) {\n      expect(rstream_).toBe(rstream);\n      // eslint-disable-next-line no-invalid-this\n      const context = this;\n\n      expect(context).toHaveProperty('node', {});\n      expect(context).toHaveProperty('current', {});\n      called = true;\n    }\n\n    decode(rstream, schema);\n    expect(called).toBeTruthy();\n  });\n\n  test('schema should be a plain object', () => {\n    const rstream = {};\n    const expectedError = 'Argument #2 should be a plain object.';\n\n    expect(() => decode(rstream, 123)).toThrow(expectedError);\n    expect(() => decode(rstream, '123')).toThrow(expectedError);\n    expect(() => decode(rstream, /.+/)).toThrow(expectedError);\n  });\n\n  test('each field should have a valid type', () => {\n    const rstream = {};\n\n    const schema = {\n      a: null,\n    };\n\n    const expectedError = `Argument #2 should be a plain object.`;\n\n    expect(() => decode(rstream, schema)).toThrow(expectedError);\n  });\n\n  test('should decode nested types', () => {\n    const rstream = {};\n    const res1 = 100;\n    const bytes = 10;\n\n    const schema = {\n      a: {\n        b: {\n          decode: () => res1,\n        },\n      },\n      c: {\n        decode: () => res1,\n      },\n    };\n\n    schema.a.b.decode.bytes = bytes;\n    schema.c.decode.bytes = bytes;\n\n    const expectedResult = {\n      a: {\n        b: res1,\n      },\n      c: res1,\n    };\n\n    const result = decode(rstream, schema);\n    expect(result).toEqual(expectedResult);\n    expect(decode.bytes).toEqual(bytes * 2);\n  });\n\n  test('should decode buffers', () => {\n    const buffer = Buffer.alloc(1);\n    const bytes = 10;\n    const res1 = 100;\n\n    const schema = {\n      a: {\n        decode: () => res1,\n      },\n    };\n\n    schema.a.decode.bytes = bytes;\n\n    const expectedResult = {\n      a: res1,\n    };\n\n    const result = decode(buffer, schema);\n\n    expect(result).toEqual(expectedResult);\n    expect(decode.bytes).toEqual(bytes);\n  });\n\n  test('should decode positive conditions', () => {\n    const rstream = {};\n    const bytes = 10;\n\n    const res1 = 100;\n    const res2 = 200;\n\n    const type1 = {\n      decode: () => res1,\n    };\n\n    const type2 = {\n      decode: () => res2,\n      encode() {},\n    };\n\n    type1.decode.bytes = bytes;\n    type2.decode.bytes = bytes;\n\n    const schema = {\n      a: type1,\n      b: when(() => true, type2),\n    };\n\n    const expectedResult = {\n      a: res1,\n      b: res2,\n    };\n\n    const result = decode(rstream, schema);\n\n    expect(result).toEqual(expectedResult);\n    expect(decode.bytes).toEqual(bytes * 2);\n  });\n\n  test('should skip negative conditions', () => {\n    const rstream = {};\n    const bytes = 10;\n\n    const res1 = 100;\n    const res2 = 200;\n\n    const type1 = {\n      decode: () => res1,\n    };\n\n    const type2 = {\n      decode: () => res2,\n      encode() {},\n    };\n\n    type1.decode.bytes = bytes;\n    type2.decode.bytes = bytes;\n\n    const schema = {\n      a: type1,\n      b: when(() => false, type2),\n    };\n\n    const expectedResult = {\n      a: res1,\n    };\n\n    const result = decode(rstream, schema);\n\n    expect(result).toEqual(expectedResult);\n    expect(decode.bytes).toEqual(bytes);\n  });\n});\n"]}