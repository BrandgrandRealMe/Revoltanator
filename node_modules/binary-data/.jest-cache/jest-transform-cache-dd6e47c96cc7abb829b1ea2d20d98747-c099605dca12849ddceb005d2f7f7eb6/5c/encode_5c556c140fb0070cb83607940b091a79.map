{"version":3,"sources":["encode.js"],"names":["reserved","require","encode","BinaryStream","describe","test","wstream","schema","a","jest","fn","b","object","bytes","expect","toHaveBeenCalledTimes","toEqual","bytes1","bytes2","itemType","decode","toBeCalled","expectedError","toThrow","encodeFn","c"],"mappings":"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","file":"encode.js","sourcesContent":["'use strict';\n\nconst reserved = require('types/reserved');\nconst { encode } = require('lib/encode');\nconst BinaryStream = require('lib/binary-stream');\n\ndescribe('encode', () => {\n  test('should encode objects using schema', () => {\n    const wstream = new BinaryStream();\n\n    const schema = {\n      a: {\n        encode: jest.fn(),\n      },\n      b: {\n        encode: jest.fn(),\n      },\n    };\n\n    const object = {\n      a: 100,\n      b: 200,\n    };\n\n    schema.a.encode.bytes = 10;\n    schema.b.encode.bytes = 33;\n\n    encode(object, wstream, schema);\n\n    expect(schema.a.encode).toHaveBeenCalledTimes(1);\n    expect(schema.b.encode).toHaveBeenCalledTimes(1);\n    expect(encode.bytes).toEqual(schema.a.encode.bytes + schema.b.encode.bytes);\n  });\n\n  test('should encode reserved fields', () => {\n    const wstream = new BinaryStream();\n\n    const bytes1 = 33;\n    const bytes2 = 10;\n\n    const itemType = {\n      encode: jest.fn(),\n      decode() {},\n    };\n\n    itemType.encode.bytes = bytes1;\n\n    const schema = {\n      a: {\n        encode: jest.fn(),\n      },\n      b: reserved(itemType, 1),\n    };\n\n    const object = {\n      a: 100,\n    };\n\n    schema.a.encode.bytes = bytes2;\n\n    encode(object, wstream, schema);\n\n    expect(schema.a.encode).toBeCalled();\n    expect(itemType.encode).toBeCalled();\n    expect(encode.bytes).toEqual(bytes1 + bytes2);\n  });\n\n  test('each field should be a valid type', () => {\n    const wstream = new BinaryStream();\n\n    const schema = {\n      a: null,\n    };\n\n    const expectedError = 'Argument `schema` should be a plain object.';\n\n    expect(() => encode({}, wstream, schema)).toThrow(expectedError);\n  });\n\n  test('schema should be a plain object', () => {\n    const wstream = new BinaryStream();\n    const expectedError = 'Argument `schema` should be a plain object.';\n\n    expect(() => encode({}, wstream, 123)).toThrow(expectedError);\n    expect(() => encode({}, wstream, '123')).toThrow(expectedError);\n    expect(() => encode({}, wstream, /.+/)).toThrow(expectedError);\n  });\n\n  test('should encode nexted objects', () => {\n    const wstream = new BinaryStream();\n\n    const encodeFn = jest.fn();\n\n    const schema = {\n      a: {\n        b: {\n          encode: encodeFn,\n        },\n      },\n      c: {\n        encode: encodeFn,\n      },\n    };\n\n    const object = {\n      a: {\n        b: 100,\n      },\n      c: 100,\n    };\n\n    encodeFn.bytes = 10;\n\n    encode(object, wstream, schema);\n    expect(encodeFn).toHaveBeenCalledTimes(2);\n    expect(encode.bytes).toEqual(encodeFn.bytes * 2);\n  });\n});\n"]}