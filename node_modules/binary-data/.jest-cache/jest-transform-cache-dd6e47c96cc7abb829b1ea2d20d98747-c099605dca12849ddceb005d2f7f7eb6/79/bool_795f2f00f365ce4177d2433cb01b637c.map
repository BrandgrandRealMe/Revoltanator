{"version":3,"sources":["bool.js"],"names":["bool","require","describe","test","wstream","itemBytes","itemType","decode","encode","jest","fn","mockImplementation","bytes","type","expect","toHaveBeenCalledTimes","toBeCalledWith","toBe","rstream","result","meta","expectedLength","value","encodingLength"],"mappings":"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","file":"bool.js","sourcesContent":["'use strict';\n\nconst bool = require('types/bool');\n\ndescribe('bool', () => {\n  test('encode positive', () => {\n    const wstream = {};\n    const itemBytes = 5;\n\n    const itemType = {\n      decode() {},\n      encode: jest.fn().mockImplementation(() => {\n        itemType.encode.bytes = itemBytes;\n      }),\n    };\n\n    const type = bool(itemType);\n    type.encode(true, wstream);\n\n    expect(itemType.encode).toHaveBeenCalledTimes(1);\n    expect(itemType.encode).toBeCalledWith(1, wstream);\n    expect(type.encode.bytes).toBe(itemBytes);\n  });\n\n  test('encode negative', () => {\n    const wstream = {};\n    const itemBytes = 5;\n\n    const itemType = {\n      decode() {},\n      encode: jest.fn().mockImplementation(() => {\n        itemType.encode.bytes = itemBytes;\n      }),\n    };\n\n    const type = bool(itemType);\n    type.encode(false, wstream);\n\n    expect(itemType.encode).toHaveBeenCalledTimes(1);\n    expect(itemType.encode).toBeCalledWith(0, wstream);\n    expect(type.encode.bytes).toBe(itemBytes);\n  });\n\n  test('decode positive', () => {\n    const rstream = {};\n    const itemBytes = 10;\n\n    const itemType = {\n      decode() {\n        return 1;\n      },\n      encode() {},\n    };\n\n    itemType.decode.bytes = itemBytes;\n\n    const type = bool(itemType);\n    const result = type.decode(rstream);\n\n    expect(result).toBe(true);\n    expect(type.decode.bytes).toBe(itemBytes);\n  });\n\n  test('decode negative', () => {\n    const rstream = {};\n    const itemBytes = 10;\n\n    const itemType = {\n      decode() {\n        return 0;\n      },\n      encode() {},\n    };\n\n    itemType.decode.bytes = itemBytes;\n\n    const meta = {\n      bytes: 0,\n    };\n\n    const type = bool(itemType);\n    const result = type.decode(rstream, meta);\n\n    expect(result).toBe(false);\n    expect(type.decode.bytes).toBe(itemBytes);\n  });\n\n  test('encodingLength', () => {\n    const expectedLength = 4;\n    const value = true;\n\n    const itemType = {\n      encode() {},\n      decode() {},\n      encodingLength() {\n        return expectedLength;\n      },\n    };\n\n    const type = bool(itemType);\n    expect(type.encodingLength(value)).toBe(expectedLength);\n  });\n});\n"]}