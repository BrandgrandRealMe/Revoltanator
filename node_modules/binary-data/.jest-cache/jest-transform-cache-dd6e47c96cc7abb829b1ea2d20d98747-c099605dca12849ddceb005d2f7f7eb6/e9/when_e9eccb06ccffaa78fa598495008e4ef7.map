{"version":3,"sources":["when.js"],"names":["when","require","symbols","describe","test","childBytes","childValue","wstream","childType","encode","jest","fn","mockImplementation","bytes","decode","context","type","expect","toEqual","skip","toHaveBeenCalledTimes","value","encodingLength","toBe","undefined"],"mappings":"AAAA;;AAEA,MAAMA,OAAOC,QAAQ,YAAR,CAAb;AACA,MAAMC,UAAUD,QAAQ,kBAAR,CAAhB;;AAEAE,SAAS,MAAT,EAAiB,MAAM;AACrBC,OAAK,iBAAL,EAAwB,MAAM;AAC5B,UAAMC,aAAa,CAAnB;AACA,UAAMC,aAAa,EAAnB;AACA,UAAMC,UAAU,EAAhB;;AAEA,UAAMC,YAAY;AAChBC,cAAQC,KAAKC,EAAL,GAAUC,kBAAV,CAA6B,MAAM;AACzCJ,kBAAUC,MAAV,CAAiBI,KAAjB,GAAyBR,UAAzB;AACD,OAFO,CADQ;AAIhBS,eAAS,CAAE;AAJK,KAAlB;;AAOA,UAAMC,UAAU,EAAhB;;AAEA,UAAMC,OAAOhB,KAAK,MAAM,IAAX,EAAiBQ,SAAjB,CAAb;;AAEAQ,SAAKP,MAAL,CAAYH,UAAZ,EAAwBC,OAAxB,EAAiCQ,OAAjC;;AAEAE,WAAOD,KAAKP,MAAL,CAAYI,KAAnB,EAA0BK,OAA1B,CAAkCb,UAAlC;AACAY,WAAOD,KAAKd,QAAQiB,IAAb,CAAP,EAA2BD,OAA3B,CAAmC,KAAnC;AACAD,WAAOT,UAAUC,MAAjB,EAAyBW,qBAAzB,CAA+C,CAA/C;AACD,GArBD;;AAuBAhB,OAAK,iBAAL,EAAwB,MAAM;AAC5B,UAAMC,aAAa,CAAnB;AACA,UAAMC,aAAa,EAAnB;AACA,UAAMC,UAAU,EAAhB;;AAEA,UAAMC,YAAY;AAChBC,cAAQC,KAAKC,EAAL,GAAUC,kBAAV,CAA6B,MAAM;AACzCJ,kBAAUC,MAAV,CAAiBI,KAAjB,GAAyBR,UAAzB;AACD,OAFO,CADQ;AAIhBS,eAAS,CAAE;AAJK,KAAlB;;AAOA,UAAMC,UAAU,EAAhB;;AAEA,UAAMC,OAAOhB,KAAK,MAAM,KAAX,EAAkBQ,SAAlB,CAAb;;AAEAQ,SAAKP,MAAL,CAAYH,UAAZ,EAAwBC,OAAxB,EAAiCQ,OAAjC;;AAEAE,WAAOD,KAAKP,MAAL,CAAYI,KAAnB,EAA0BK,OAA1B,CAAkC,CAAlC;AACAD,WAAOD,KAAKd,QAAQiB,IAAb,CAAP,EAA2BD,OAA3B,CAAmC,IAAnC;AACAD,WAAOT,UAAUC,MAAjB,EAAyBW,qBAAzB,CAA+C,CAA/C;AACD,GArBD;;AAuBAhB,OAAK,yBAAL,EAAgC,MAAM;AACpC,UAAMiB,QAAQ,GAAd;AACA,UAAMR,QAAQ,EAAd;;AAEA,UAAML,YAAY;AAChBM,eAAS,CAAE,CADK;AAEhBL,eAAS,CAAE,CAFK;AAGhBa,uBAAiB;AACf,eAAOT,KAAP;AACD;AALe,KAAlB;;AAQA,UAAMG,OAAOhB,KAAK,MAAM,IAAX,EAAiBQ,SAAjB,CAAb;;AAEAS,WAAOD,KAAKM,cAAL,CAAoBD,KAApB,CAAP,EAAmCE,IAAnC,CAAwCV,KAAxC;AACD,GAfD;;AAiBAT,OAAK,yBAAL,EAAgC,MAAM;AACpC,UAAMiB,QAAQ,GAAd;AACA,UAAMR,QAAQ,EAAd;;AAEA,UAAML,YAAY;AAChBM,eAAS,CAAE,CADK;AAEhBL,eAAS,CAAE,CAFK;AAGhBa,uBAAiB;AACf,eAAOT,KAAP;AACD;AALe,KAAlB;;AAQA,UAAMG,OAAOhB,KAAK,MAAM,KAAX,EAAkBQ,SAAlB,CAAb;;AAEAS,WAAOD,KAAKM,cAAL,CAAoBD,KAApB,CAAP,EAAmCE,IAAnC,CAAwC,CAAxC;AACD,GAfD;;AAiBAnB,OAAK,iBAAL,EAAwB,MAAM;AAC5B,UAAMC,aAAa,CAAnB;AACA,UAAMC,aAAa,EAAnB;;AAEA,UAAME,YAAY;AAChBM,cAAQ,MAAMR,UADE;AAEhBG,eAAS,CAAE;AAFK,KAAlB;;AAKAD,cAAUM,MAAV,CAAiBD,KAAjB,GAAyBR,UAAzB;;AAEA,UAAMW,OAAOhB,KAAK,MAAM,IAAX,EAAiBQ,SAAjB,CAAb;;AAEAS,WAAOD,KAAKF,MAAL,CAAY,EAAZ,CAAP,EAAwBI,OAAxB,CAAgCZ,UAAhC;AACAW,WAAOD,KAAKF,MAAL,CAAYD,KAAnB,EAA0BK,OAA1B,CAAkCb,UAAlC;AACAY,WAAOD,KAAKd,QAAQiB,IAAb,CAAP,EAA2BD,OAA3B,CAAmC,KAAnC;AACD,GAhBD;;AAkBAd,OAAK,iBAAL,EAAwB,MAAM;AAC5B,UAAMC,aAAa,CAAnB;AACA,UAAMC,aAAa,EAAnB;;AAEA,UAAME,YAAY;AAChBM,cAAQ,MAAMR,UADE;AAEhBG,eAAS,CAAE;AAFK,KAAlB;;AAKAD,cAAUM,MAAV,CAAiBD,KAAjB,GAAyBR,UAAzB;;AAEA,UAAMW,OAAOhB,KAAK,MAAM,KAAX,EAAkBQ,SAAlB,CAAb;;AAEAS,WAAOD,KAAKF,MAAL,CAAY,EAAZ,CAAP,EAAwBI,OAAxB,CAAgCM,SAAhC;AACAP,WAAOD,KAAKF,MAAL,CAAYD,KAAnB,EAA0BK,OAA1B,CAAkC,CAAlC;AACAD,WAAOD,KAAKd,QAAQiB,IAAb,CAAP,EAA2BD,OAA3B,CAAmC,IAAnC;AACD,GAhBD;AAiBD,CApHD","file":"when.js","sourcesContent":["'use strict';\n\nconst when = require('types/when');\nconst symbols = require('internal/symbols');\n\ndescribe('when', () => {\n  test('encode positive', () => {\n    const childBytes = 3;\n    const childValue = 12;\n    const wstream = {};\n\n    const childType = {\n      encode: jest.fn().mockImplementation(() => {\n        childType.encode.bytes = childBytes;\n      }),\n      decode() {},\n    };\n\n    const context = {};\n\n    const type = when(() => true, childType);\n\n    type.encode(childValue, wstream, context);\n\n    expect(type.encode.bytes).toEqual(childBytes);\n    expect(type[symbols.skip]).toEqual(false);\n    expect(childType.encode).toHaveBeenCalledTimes(1);\n  });\n\n  test('encode negative', () => {\n    const childBytes = 3;\n    const childValue = 12;\n    const wstream = {};\n\n    const childType = {\n      encode: jest.fn().mockImplementation(() => {\n        childType.encode.bytes = childBytes;\n      }),\n      decode() {},\n    };\n\n    const context = {};\n\n    const type = when(() => false, childType);\n\n    type.encode(childValue, wstream, context);\n\n    expect(type.encode.bytes).toEqual(0);\n    expect(type[symbols.skip]).toEqual(true);\n    expect(childType.encode).toHaveBeenCalledTimes(0);\n  });\n\n  test('encodingLength positive', () => {\n    const value = 123;\n    const bytes = 10;\n\n    const childType = {\n      decode() {},\n      encode() {},\n      encodingLength() {\n        return bytes;\n      },\n    };\n\n    const type = when(() => true, childType);\n\n    expect(type.encodingLength(value)).toBe(bytes);\n  });\n\n  test('encodingLength negative', () => {\n    const value = 123;\n    const bytes = 10;\n\n    const childType = {\n      decode() {},\n      encode() {},\n      encodingLength() {\n        return bytes;\n      },\n    };\n\n    const type = when(() => false, childType);\n\n    expect(type.encodingLength(value)).toBe(0);\n  });\n\n  test('decode positive', () => {\n    const childBytes = 3;\n    const childValue = 12;\n\n    const childType = {\n      decode: () => childValue,\n      encode() {},\n    };\n\n    childType.decode.bytes = childBytes;\n\n    const type = when(() => true, childType);\n\n    expect(type.decode({})).toEqual(childValue);\n    expect(type.decode.bytes).toEqual(childBytes);\n    expect(type[symbols.skip]).toEqual(false);\n  });\n\n  test('decode negative', () => {\n    const childBytes = 3;\n    const childValue = 12;\n\n    const childType = {\n      decode: () => childValue,\n      encode() {},\n    };\n\n    childType.decode.bytes = childBytes;\n\n    const type = when(() => false, childType);\n\n    expect(type.decode({})).toEqual(undefined);\n    expect(type.decode.bytes).toEqual(0);\n    expect(type[symbols.skip]).toEqual(true);\n  });\n});\n"]}