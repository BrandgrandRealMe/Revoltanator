2e62e83a5103ec393aa9f8596a07e51f
'use strict';

const array = require('types/array');

describe('array', () => {
  const rstream = {};

  describe('fixed length', () => {
    describe('length is the number of items', () => {
      test('encode', () => {
        const itemBytes = 7;
        const items = [10, 20];
        const wstream = {};

        const itemType = {
          decode() {},
          encode: jest.fn()
        };

        itemType.encode.bytes = itemBytes;

        const type = array(itemType, items.length);
        type.encode(items, wstream);

        expect(itemType.encode).toHaveBeenCalledTimes(items.length);
        expect(type.encode.bytes).toBe(itemBytes * items.length);
      });

      test('throws when length != items.length', () => {
        const items = [10, 20];
        const wstream = {};

        const itemType = {
          decode() {},
          encode: jest.fn()
        };

        const requiredSize = items.length + 1;
        const type = array(itemType, requiredSize);

        expect(() => type.encode(items, wstream)).toThrow(`Argument #1 required length ${requiredSize} instead of ${items.length}`);
      });

      test('decode', () => {
        const length = 2;
        const bytes = 10;

        const first = 1;
        const second = 2;
        const items = [first, second];

        const itemType = {
          decode() {
            return items.shift();
          },
          encode() {}
        };

        itemType.decode.bytes = bytes;

        const type = array(itemType, length);

        expect(type.decode(rstream)).toEqual([first, second]);
        expect(type.decode.bytes).toBe(bytes * length);
      });

      test('encodingLength', () => {
        const items = [10, 20];
        const bytes = 3;

        const itemType = {
          encode() {},
          decode() {},
          encodingLength() {
            return bytes;
          }
        };

        const type = array(itemType, items.length);

        expect(type.encodingLength(items)).toBe(items.length * bytes);
      });
    });

    describe('length is the number of bytes', () => {
      test('encode', () => {
        const bytes = 7;
        const items = [10, 20];
        const length = bytes * items.length;
        const wstream = {};

        const itemType = {
          encode: jest.fn(),
          decode() {},
          encodingLength() {
            return bytes;
          }
        };

        itemType.encode.bytes = bytes;

        const type = array(itemType, length, 'bytes');
        type.encode(items, wstream);

        expect(itemType.encode).toHaveBeenCalledTimes(items.length);
        expect(type.encode.bytes).toBe(length);
      });

      test('decode', () => {
        const first = 1;
        const second = 2;
        const items = [first, second];

        const bytes = 3;
        const length = bytes * items.length;

        const meta = {
          bytes: 0,
          context: {}
        };

        const itemType = {
          decode() {
            return items.shift();
          },
          encode() {}
        };

        itemType.decode.bytes = bytes;
        const type = array(itemType, length, 'bytes');

        expect(type.decode(rstream, meta)).toEqual([first, second]);
        expect(type.decode.bytes).toBe(length);
      });

      test('encodingLength', () => {
        const items = [10, 20];
        const bytes = 3;
        const length = items.length * bytes;

        const itemType = {
          encode() {},
          decode() {},
          encodingLength() {
            return bytes;
          }
        };

        const type = array(itemType, length, 'bytes');

        expect(type.encodingLength(items)).toBe(length);
      });
    });
  });

  describe('length is type', () => {
    describe('length is the number of items', () => {
      test('encode', () => {
        const items = [100, 200, 300];
        const wstream = {};

        const lengthType = {
          decode() {},
          encode: jest.fn()
        };

        lengthType.encode.bytes = 2;

        const itemType = {
          decode() {},
          encode: jest.fn()
        };

        itemType.encode.bytes = 3;

        const type = array(itemType, lengthType);
        type.encode(items, wstream);

        expect(lengthType.encode).toHaveBeenCalledTimes(1);
        expect(lengthType.encode).toBeCalledWith(items.length, wstream);
        expect(itemType.encode).toHaveBeenCalledTimes(items.length);
        expect(type.encode.bytes).toBe(itemType.encode.bytes * items.length + lengthType.encode.bytes);
      });

      test('decode', () => {
        const first = 1;
        const second = 2;
        const items = [first, second];

        const { length } = items;
        const itemBytes = 3;
        const lengthBytes = 3;

        const itemType = {
          decode() {
            return items.shift();
          },
          encode() {}
        };

        itemType.decode.bytes = itemBytes;

        const lengthType = {
          decode() {
            return length;
          },
          encode() {}
        };

        lengthType.decode.bytes = lengthBytes;

        const type = array(itemType, lengthType);

        expect(type.decode(rstream)).toEqual([first, second]);
        expect(type.decode.bytes).toBe(itemBytes * length + lengthBytes);
      });

      test('encodingLength', () => {
        const items = [10, 20];
        const itemBytes = 3;
        const lengthBytes = 5;

        const lengthType = {
          encode() {},
          decode() {},
          encodingLength() {
            return lengthBytes;
          }
        };

        const itemType = {
          encode() {},
          decode() {},
          encodingLength() {
            return itemBytes;
          }
        };

        const type = array(itemType, lengthType);

        expect(type.encodingLength(items)).toBe(items.length * itemBytes + lengthBytes);
      });
    });

    describe('length is the number of bytes', () => {
      test('encode', () => {
        const items = [100, 200, 300];
        const itemBytes = 4;
        const wstream = {};

        const lengthType = {
          decode() {},
          encode: jest.fn()
        };

        lengthType.encode.bytes = 2;

        const itemType = {
          decode() {},
          encode: jest.fn(),
          encodingLength() {
            return itemBytes;
          }
        };

        itemType.encode.bytes = itemBytes;

        const type = array(itemType, lengthType, 'bytes');
        type.encode(items, wstream);

        expect(lengthType.encode).toHaveBeenCalledTimes(1);
        expect(lengthType.encode).toBeCalledWith(items.length * itemBytes, wstream);
        expect(itemType.encode).toHaveBeenCalledTimes(items.length);
        expect(type.encode.bytes).toBe(itemBytes * items.length + lengthType.encode.bytes);
      });

      test('decode', () => {
        const first = 1;
        const second = 2;
        const items = [first, second];

        const { length } = items;
        const itemBytes = 3;
        const lengthBytes = 3;

        const itemType = {
          decode() {
            return items.shift();
          },
          encode() {}
        };

        itemType.decode.bytes = itemBytes;

        const lengthType = {
          decode() {
            return length * itemBytes;
          },
          encode() {}
        };

        lengthType.decode.bytes = lengthBytes;

        const type = array(itemType, lengthType, 'bytes');

        expect(type.decode(rstream)).toEqual([first, second]);
        expect(type.decode.bytes).toBe(itemBytes * length + lengthBytes);
      });

      test('encodingLength', () => {
        const items = [10, 20];
        const itemBytes = 3;
        const lengthBytes = 5;

        const lengthType = {
          encode() {},
          decode() {},
          encodingLength() {
            return lengthBytes;
          }
        };

        const itemType = {
          encode() {},
          decode() {},
          encodingLength() {
            return itemBytes;
          }
        };

        const type = array(itemType, lengthType, 'bytes');

        expect(type.encodingLength(items)).toBe(items.length * itemBytes + lengthBytes);
      });
    });
  });

  describe('item is an user defined type', () => {
    test('encode', () => {
      const wstream = {};
      const items = [{ a: 100 }, { a: 200 }, { a: 300 }];
      const itemBytes = 4;

      const schema = {
        a: {
          encode: jest.fn(),
          decode() {}
        }
      };

      schema.a.encode.bytes = itemBytes;

      const type = array(schema, items.length);
      type.encode(items, wstream);

      expect(schema.a.encode).toHaveBeenCalledTimes(items.length);
      expect(type.encode.bytes).toBe(itemBytes * items.length);
    });

    test('decode', () => {
      const firstItem = 1;
      const secondItem = 2;
      const items = [firstItem, secondItem];

      const { length } = items;
      const itemBytes = 2;

      const itemType = {
        decode() {
          return items.shift();
        },
        encode() {}
      };

      itemType.decode.bytes = itemBytes;

      const schema = {
        a: itemType
      };

      const type = array(schema, length);

      expect(type.decode(rstream)).toEqual([{ a: firstItem }, { a: secondItem }]);
      expect(type.decode.bytes).toBe(itemBytes * length);
    });

    test('encodingLength', () => {
      const itemBytes = 3;
      const items = [{ a: 100 }, { a: 200 }, { a: 300 }];

      const schema = {
        a: {
          encode() {},
          decode() {},
          encodingLength() {
            return itemBytes;
          }
        }
      };

      const type = array(schema, items.length);

      expect(type.encodingLength(items)).toBe(itemBytes * items.length);
    });
  });

  describe('length is function', () => {
    describe('length is the number of items', () => {
      test('decode', () => {
        const first = 1;
        const second = 2;
        const items = [first, second];

        const { length } = items;
        const bytes = 3;

        const itemType = {
          decode() {
            return items.shift();
          },
          encode() {}
        };

        itemType.decode.bytes = bytes;
        const callback = jest.fn().mockImplementation(() => length);

        const type = array(itemType, callback);

        expect(type.decode(rstream)).toEqual([first, second]);
        expect(callback).toHaveBeenCalledTimes(1);
        expect(type.decode.bytes).toBe(bytes * length);
      });

      test('encode', () => {
        const wstream = {};
        const items = [100, 200, 300];
        const { length } = items;
        const bytes = 4;

        const itemType = {
          decode() {},
          encode: jest.fn()
        };

        itemType.encode.bytes = bytes;

        const callback = jest.fn().mockImplementation(() => length);

        const type = array(itemType, callback);
        type.encode(items, wstream);

        expect(callback).toHaveBeenCalledTimes(1);
        expect(itemType.encode).toHaveBeenCalledTimes(items.length);
        expect(type.encode.bytes).toBe(bytes * items.length);
      });

      test('encodingLength', () => {
        const items = [10, 20];
        const bytes = 3;

        const itemType = {
          encode() {},
          decode() {},
          encodingLength() {
            return bytes;
          }
        };

        const type = array(itemType, () => {});

        expect(type.encodingLength(items)).toBe(items.length * bytes);
      });
    });

    describe('length is the number of bytes', () => {
      test('decode', () => {
        const first = 1;
        const second = 2;
        const items = [first, second];

        const bytes = 3;
        const { length } = items;

        const itemType = {
          decode() {
            return items.shift();
          },
          encode() {}
        };

        itemType.decode.bytes = bytes;
        const callback = jest.fn().mockImplementation(() => length * bytes);

        const type = array(itemType, callback, 'bytes');

        expect(type.decode(rstream)).toEqual([first, second]);
        expect(callback).toHaveBeenCalledTimes(1);
        expect(type.decode.bytes).toBe(length * bytes);
      });

      test('encode', () => {
        const wstream = {};
        const items = [100, 200, 300];

        const bytes = 4;
        const { length } = items;

        const callback = jest.fn().mockImplementation(() => length * bytes);

        const itemType = {
          decode() {},
          encode: jest.fn(),
          encodingLength() {
            return bytes;
          }
        };

        itemType.encode.bytes = bytes;

        const type = array(itemType, callback, 'bytes');
        type.encode(items, wstream);

        expect(callback).toHaveBeenCalledTimes(1);
        expect(itemType.encode).toHaveBeenCalledTimes(length);
        expect(type.encode.bytes).toBe(bytes * length);
      });

      test('encodingLength', () => {
        const items = [10, 20];
        const bytes = 3;
        const length = items.length * bytes;

        const itemType = {
          encode() {},
          decode() {},
          encodingLength() {
            return bytes;
          }
        };

        const schema = array(itemType, () => {}, 'bytes');

        expect(schema.encodingLength(items)).toBe(length);
      });
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFycmF5LmpzIl0sIm5hbWVzIjpbImFycmF5IiwicmVxdWlyZSIsImRlc2NyaWJlIiwicnN0cmVhbSIsInRlc3QiLCJpdGVtQnl0ZXMiLCJpdGVtcyIsIndzdHJlYW0iLCJpdGVtVHlwZSIsImRlY29kZSIsImVuY29kZSIsImplc3QiLCJmbiIsImJ5dGVzIiwidHlwZSIsImxlbmd0aCIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsInRvQmUiLCJyZXF1aXJlZFNpemUiLCJ0b1Rocm93IiwiZmlyc3QiLCJzZWNvbmQiLCJzaGlmdCIsInRvRXF1YWwiLCJlbmNvZGluZ0xlbmd0aCIsIm1ldGEiLCJjb250ZXh0IiwibGVuZ3RoVHlwZSIsInRvQmVDYWxsZWRXaXRoIiwibGVuZ3RoQnl0ZXMiLCJhIiwic2NoZW1hIiwiZmlyc3RJdGVtIiwic2Vjb25kSXRlbSIsImNhbGxiYWNrIiwibW9ja0ltcGxlbWVudGF0aW9uIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxNQUFNQSxRQUFRQyxRQUFRLGFBQVIsQ0FBZDs7QUFFQUMsU0FBUyxPQUFULEVBQWtCLE1BQU07QUFDdEIsUUFBTUMsVUFBVSxFQUFoQjs7QUFFQUQsV0FBUyxjQUFULEVBQXlCLE1BQU07QUFDN0JBLGFBQVMsK0JBQVQsRUFBMEMsTUFBTTtBQUM5Q0UsV0FBSyxRQUFMLEVBQWUsTUFBTTtBQUNuQixjQUFNQyxZQUFZLENBQWxCO0FBQ0EsY0FBTUMsUUFBUSxDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWQ7QUFDQSxjQUFNQyxVQUFVLEVBQWhCOztBQUVBLGNBQU1DLFdBQVc7QUFDZkMsbUJBQVMsQ0FBRSxDQURJO0FBRWZDLGtCQUFRQyxLQUFLQyxFQUFMO0FBRk8sU0FBakI7O0FBS0FKLGlCQUFTRSxNQUFULENBQWdCRyxLQUFoQixHQUF3QlIsU0FBeEI7O0FBRUEsY0FBTVMsT0FBT2QsTUFBTVEsUUFBTixFQUFnQkYsTUFBTVMsTUFBdEIsQ0FBYjtBQUNBRCxhQUFLSixNQUFMLENBQVlK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QixDQUE4Q0YsTUFBOUM7QUFDQUMsZUFBT0YsS0FBS0osTUFBTCxDQUFZRyxLQUFuQixFQUEwQkssSUFBMUIsQ0FBK0JMLFFBQVFFLE1BQXZDO0FBQ0QsT0F6QkQ7O0FBMkJBWCxXQUFLLGdCQUFMLEVBQXVCLE1BQU07QUFDM0IsY0FBTUUsUUFBUSxDQUFDLEVBQUQsRUFBSyxFQUFMLENBQWQ7QUFDQSxjQUFNTyxRQUFRLENBQWQ7QUFDQSxjQUFNRSxTQUFTVCxNQUFNUyxNQUFOLEdBQWVGLEtBQTlCOztBQUVBLGNBQU1MLFdBQVc7QUFDZkUsbUJBQVMsQ0FBRSxDQURJO0FBRWZELG1CQUFTLENBQUUsQ0FGSTtBQUdmZ0IsMkJBQWlCO0FBQ2YsbUJBQU9aLEtBQVA7QUFDRDtBQUxjLFNBQWpCOztBQVFBLGNBQU1tQixTQUFTaEMsTUFBTVEsUUFBTixFQUFnQixNQUFNLENBQUUsQ0FBeEIsRUFBMEIsT0FBMUIsQ0FBZjs7QUFFQVEsZUFBT2dCLE9BQU9QLGNBQVAsQ0FBc0JuQixLQUF0QixDQUFQLEVBQXFDWSxJQUFyQyxDQUEwQ0gsTUFBMUM7QUFDRCxPQWhCRDtBQWlCRCxLQXRFRDtBQXVFRCxHQTNJRDtBQTRJRCxDQWhqQkQiLCJmaWxlIjoiYXJyYXkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFycmF5ID0gcmVxdWlyZSgndHlwZXMvYXJyYXknKTtcblxuZGVzY3JpYmUoJ2FycmF5JywgKCkgPT4ge1xuICBjb25zdCByc3RyZWFtID0ge307XG5cbiAgZGVzY3JpYmUoJ2ZpeGVkIGxlbmd0aCcsICgpID0+IHtcbiAgICBkZXNjcmliZSgnbGVuZ3RoIGlzIHRoZSBudW1iZXIgb2YgaXRlbXMnLCAoKSA9PiB7XG4gICAgICB0ZXN0KCdlbmNvZGUnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW1CeXRlcyA9IDc7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWzEwLCAyMF07XG4gICAgICAgIGNvbnN0IHdzdHJlYW0gPSB7fTtcblxuICAgICAgICBjb25zdCBpdGVtVHlwZSA9IHtcbiAgICAgICAgICBkZWNvZGUoKSB7fSxcbiAgICAgICAgICBlbmNvZGU6IGplc3QuZm4oKSxcbiAgICAgICAgfTtcblxuICAgICAgICBpdGVtVHlwZS5lbmNvZGUuYnl0ZXMgPSBpdGVtQnl0ZXM7XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IGFycmF5KGl0ZW1UeXBlLCBpdGVtcy5sZW5ndGgpO1xuICAgICAgICB0eXBlLmVuY29kZShpdGVtcywgd3N0cmVhbSk7XG5cbiAgICAgICAgZXhwZWN0KGl0ZW1UeXBlLmVuY29kZSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgIGV4cGVjdCh0eXBlLmVuY29kZS5ieXRlcykudG9CZShpdGVtQnl0ZXMgKiBpdGVtcy5sZW5ndGgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ3Rocm93cyB3aGVuIGxlbmd0aCAhPSBpdGVtcy5sZW5ndGgnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWzEwLCAyMF07XG4gICAgICAgIGNvbnN0IHdzdHJlYW0gPSB7fTtcblxuICAgICAgICBjb25zdCBpdGVtVHlwZSA9IHtcbiAgICAgICAgICBkZWNvZGUoKSB7fSxcbiAgICAgICAgICBlbmNvZGU6IGplc3QuZm4oKSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCByZXF1aXJlZFNpemUgPSBpdGVtcy5sZW5ndGggKyAxO1xuICAgICAgICBjb25zdCB0eXBlID0gYXJyYXkoaXRlbVR5cGUsIHJlcXVpcmVkU2l6ZSk7XG5cbiAgICAgICAgZXhwZWN0KCgpID0+IHR5cGUuZW5jb2RlKGl0ZW1zLCB3c3RyZWFtKSkudG9UaHJvdyhcbiAgICAgICAgICBgQXJndW1lbnQgIzEgcmVxdWlyZWQgbGVuZ3RoICR7cmVxdWlyZWRTaXplfSBpbnN0ZWFkIG9mICR7XG4gICAgICAgICAgICBpdGVtcy5sZW5ndGhcbiAgICAgICAgICB9YFxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ2RlY29kZScsICgpID0+IHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gMjtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSAxMDtcblxuICAgICAgICBjb25zdCBmaXJzdCA9IDE7XG4gICAgICAgIGNvbnN0IHNlY29uZCA9IDI7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW2ZpcnN0LCBzZWNvbmRdO1xuXG4gICAgICAgIGNvbnN0IGl0ZW1UeXBlID0ge1xuICAgICAgICAgIGRlY29kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcy5zaGlmdCgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5jb2RlKCkge30sXG4gICAgICAgIH07XG5cbiAgICAgICAgaXRlbVR5cGUuZGVjb2RlLmJ5dGVzID0gYnl0ZXM7XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IGFycmF5KGl0ZW1UeXBlLCBsZW5ndGgpO1xuXG4gICAgICAgIGV4cGVjdCh0eXBlLmRlY29kZShyc3RyZWFtKSkudG9FcXVhbChbZmlyc3QsIHNlY29uZF0pO1xuICAgICAgICBleHBlY3QodHlwZS5kZWNvZGUuYnl0ZXMpLnRvQmUoYnl0ZXMgKiBsZW5ndGgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ2VuY29kaW5nTGVuZ3RoJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBpdGVtcyA9IFsxMCwgMjBdO1xuICAgICAgICBjb25zdCBieXRlcyA9IDM7XG5cbiAgICAgICAgY29uc3QgaXRlbVR5cGUgPSB7XG4gICAgICAgICAgZW5jb2RlKCkge30sXG4gICAgICAgICAgZGVjb2RlKCkge30sXG4gICAgICAgICAgZW5jb2RpbmdMZW5ndGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB0eXBlID0gYXJyYXkoaXRlbVR5cGUsIGl0ZW1zLmxlbmd0aCk7XG5cbiAgICAgICAgZXhwZWN0KHR5cGUuZW5jb2RpbmdMZW5ndGgoaXRlbXMpKS50b0JlKGl0ZW1zLmxlbmd0aCAqIGJ5dGVzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2xlbmd0aCBpcyB0aGUgbnVtYmVyIG9mIGJ5dGVzJywgKCkgPT4ge1xuICAgICAgdGVzdCgnZW5jb2RlJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBieXRlcyA9IDc7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWzEwLCAyMF07XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVzICogaXRlbXMubGVuZ3RoO1xuICAgICAgICBjb25zdCB3c3RyZWFtID0ge307XG5cbiAgICAgICAgY29uc3QgaXRlbVR5cGUgPSB7XG4gICAgICAgICAgZW5jb2RlOiBqZXN0LmZuKCksXG4gICAgICAgICAgZGVjb2RlKCkge30sXG4gICAgICAgICAgZW5jb2RpbmdMZW5ndGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBpdGVtVHlwZS5lbmNvZGUuYnl0ZXMgPSBieXRlcztcblxuICAgICAgICBjb25zdCB0eXBlID0gYXJyYXkoaXRlbVR5cGUsIGxlbmd0aCwgJ2J5dGVzJyk7XG4gICAgICAgIHR5cGUuZW5jb2RlKGl0ZW1zLCB3c3RyZWFtKTtcblxuICAgICAgICBleHBlY3QoaXRlbVR5cGUuZW5jb2RlKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgZXhwZWN0KHR5cGUuZW5jb2RlLmJ5dGVzKS50b0JlKGxlbmd0aCk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdCgnZGVjb2RlJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBmaXJzdCA9IDE7XG4gICAgICAgIGNvbnN0IHNlY29uZCA9IDI7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW2ZpcnN0LCBzZWNvbmRdO1xuXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gMztcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZXMgKiBpdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICBieXRlczogMCxcbiAgICAgICAgICBjb250ZXh0OiB7fSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBpdGVtVHlwZSA9IHtcbiAgICAgICAgICBkZWNvZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuY29kZSgpIHt9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGl0ZW1UeXBlLmRlY29kZS5ieXRlcyA9IGJ5dGVzO1xuICAgICAgICBjb25zdCB0eXBlID0gYXJyYXkoaXRlbVR5cGUsIGxlbmd0aCwgJ2J5dGVzJyk7XG5cbiAgICAgICAgZXhwZWN0KHR5cGUuZGVjb2RlKHJzdHJlYW0sIG1ldGEpKS50b0VxdWFsKFtmaXJzdCwgc2Vjb25kXSk7XG4gICAgICAgIGV4cGVjdCh0eXBlLmRlY29kZS5ieXRlcykudG9CZShsZW5ndGgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ2VuY29kaW5nTGVuZ3RoJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBpdGVtcyA9IFsxMCwgMjBdO1xuICAgICAgICBjb25zdCBieXRlcyA9IDM7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGl0ZW1zLmxlbmd0aCAqIGJ5dGVzO1xuXG4gICAgICAgIGNvbnN0IGl0ZW1UeXBlID0ge1xuICAgICAgICAgIGVuY29kZSgpIHt9LFxuICAgICAgICAgIGRlY29kZSgpIHt9LFxuICAgICAgICAgIGVuY29kaW5nTGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IGFycmF5KGl0ZW1UeXBlLCBsZW5ndGgsICdieXRlcycpO1xuXG4gICAgICAgIGV4cGVjdCh0eXBlLmVuY29kaW5nTGVuZ3RoKGl0ZW1zKSkudG9CZShsZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdsZW5ndGggaXMgdHlwZScsICgpID0+IHtcbiAgICBkZXNjcmliZSgnbGVuZ3RoIGlzIHRoZSBudW1iZXIgb2YgaXRlbXMnLCAoKSA9PiB7XG4gICAgICB0ZXN0KCdlbmNvZGUnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWzEwMCwgMjAwLCAzMDBdO1xuICAgICAgICBjb25zdCB3c3RyZWFtID0ge307XG5cbiAgICAgICAgY29uc3QgbGVuZ3RoVHlwZSA9IHtcbiAgICAgICAgICBkZWNvZGUoKSB7fSxcbiAgICAgICAgICBlbmNvZGU6IGplc3QuZm4oKSxcbiAgICAgICAgfTtcblxuICAgICAgICBsZW5ndGhUeXBlLmVuY29kZS5ieXRlcyA9IDI7XG5cbiAgICAgICAgY29uc3QgaXRlbVR5cGUgPSB7XG4gICAgICAgICAgZGVjb2RlKCkge30sXG4gICAgICAgICAgZW5jb2RlOiBqZXN0LmZuKCksXG4gICAgICAgIH07XG5cbiAgICAgICAgaXRlbVR5cGUuZW5jb2RlLmJ5dGVzID0gMztcblxuICAgICAgICBjb25zdCB0eXBlID0gYXJyYXkoaXRlbVR5cGUsIGxlbmd0aFR5cGUpO1xuICAgICAgICB0eXBlLmVuY29kZShpdGVtcywgd3N0cmVhbSk7XG5cbiAgICAgICAgZXhwZWN0KGxlbmd0aFR5cGUuZW5jb2RlKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgIGV4cGVjdChsZW5ndGhUeXBlLmVuY29kZSkudG9CZUNhbGxlZFdpdGgoaXRlbXMubGVuZ3RoLCB3c3RyZWFtKTtcbiAgICAgICAgZXhwZWN0KGl0ZW1UeXBlLmVuY29kZSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgIGV4cGVjdCh0eXBlLmVuY29kZS5ieXRlcykudG9CZShcbiAgICAgICAgICBpdGVtVHlwZS5lbmNvZGUuYnl0ZXMgKiBpdGVtcy5sZW5ndGggKyBsZW5ndGhUeXBlLmVuY29kZS5ieXRlc1xuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ2RlY29kZScsICgpID0+IHtcbiAgICAgICAgY29uc3QgZmlyc3QgPSAxO1xuICAgICAgICBjb25zdCBzZWNvbmQgPSAyO1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtmaXJzdCwgc2Vjb25kXTtcblxuICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gaXRlbXM7XG4gICAgICAgIGNvbnN0IGl0ZW1CeXRlcyA9IDM7XG4gICAgICAgIGNvbnN0IGxlbmd0aEJ5dGVzID0gMztcblxuICAgICAgICBjb25zdCBpdGVtVHlwZSA9IHtcbiAgICAgICAgICBkZWNvZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuY29kZSgpIHt9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGl0ZW1UeXBlLmRlY29kZS5ieXRlcyA9IGl0ZW1CeXRlcztcblxuICAgICAgICBjb25zdCBsZW5ndGhUeXBlID0ge1xuICAgICAgICAgIGRlY29kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmNvZGUoKSB7fSxcbiAgICAgICAgfTtcblxuICAgICAgICBsZW5ndGhUeXBlLmRlY29kZS5ieXRlcyA9IGxlbmd0aEJ5dGVzO1xuXG4gICAgICAgIGNvbnN0IHR5cGUgPSBhcnJheShpdGVtVHlwZSwgbGVuZ3RoVHlwZSk7XG5cbiAgICAgICAgZXhwZWN0KHR5cGUuZGVjb2RlKHJzdHJlYW0pKS50b0VxdWFsKFtmaXJzdCwgc2Vjb25kXSk7XG4gICAgICAgIGV4cGVjdCh0eXBlLmRlY29kZS5ieXRlcykudG9CZShpdGVtQnl0ZXMgKiBsZW5ndGggKyBsZW5ndGhCeXRlcyk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdCgnZW5jb2RpbmdMZW5ndGgnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWzEwLCAyMF07XG4gICAgICAgIGNvbnN0IGl0ZW1CeXRlcyA9IDM7XG4gICAgICAgIGNvbnN0IGxlbmd0aEJ5dGVzID0gNTtcblxuICAgICAgICBjb25zdCBsZW5ndGhUeXBlID0ge1xuICAgICAgICAgIGVuY29kZSgpIHt9LFxuICAgICAgICAgIGRlY29kZSgpIHt9LFxuICAgICAgICAgIGVuY29kaW5nTGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aEJ5dGVzO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaXRlbVR5cGUgPSB7XG4gICAgICAgICAgZW5jb2RlKCkge30sXG4gICAgICAgICAgZGVjb2RlKCkge30sXG4gICAgICAgICAgZW5jb2RpbmdMZW5ndGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbUJ5dGVzO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IGFycmF5KGl0ZW1UeXBlLCBsZW5ndGhUeXBlKTtcblxuICAgICAgICBleHBlY3QodHlwZS5lbmNvZGluZ0xlbmd0aChpdGVtcykpLnRvQmUoXG4gICAgICAgICAgaXRlbXMubGVuZ3RoICogaXRlbUJ5dGVzICsgbGVuZ3RoQnl0ZXNcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2xlbmd0aCBpcyB0aGUgbnVtYmVyIG9mIGJ5dGVzJywgKCkgPT4ge1xuICAgICAgdGVzdCgnZW5jb2RlJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBpdGVtcyA9IFsxMDAsIDIwMCwgMzAwXTtcbiAgICAgICAgY29uc3QgaXRlbUJ5dGVzID0gNDtcbiAgICAgICAgY29uc3Qgd3N0cmVhbSA9IHt9O1xuXG4gICAgICAgIGNvbnN0IGxlbmd0aFR5cGUgPSB7XG4gICAgICAgICAgZGVjb2RlKCkge30sXG4gICAgICAgICAgZW5jb2RlOiBqZXN0LmZuKCksXG4gICAgICAgIH07XG5cbiAgICAgICAgbGVuZ3RoVHlwZS5lbmNvZGUuYnl0ZXMgPSAyO1xuXG4gICAgICAgIGNvbnN0IGl0ZW1UeXBlID0ge1xuICAgICAgICAgIGRlY29kZSgpIHt9LFxuICAgICAgICAgIGVuY29kZTogamVzdC5mbigpLFxuICAgICAgICAgIGVuY29kaW5nTGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1CeXRlcztcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGl0ZW1UeXBlLmVuY29kZS5ieXRlcyA9IGl0ZW1CeXRlcztcblxuICAgICAgICBjb25zdCB0eXBlID0gYXJyYXkoaXRlbVR5cGUsIGxlbmd0aFR5cGUsICdieXRlcycpO1xuICAgICAgICB0eXBlLmVuY29kZShpdGVtcywgd3N0cmVhbSk7XG5cbiAgICAgICAgZXhwZWN0KGxlbmd0aFR5cGUuZW5jb2RlKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgIGV4cGVjdChsZW5ndGhUeXBlLmVuY29kZSkudG9CZUNhbGxlZFdpdGgoXG4gICAgICAgICAgaXRlbXMubGVuZ3RoICogaXRlbUJ5dGVzLFxuICAgICAgICAgIHdzdHJlYW1cbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KGl0ZW1UeXBlLmVuY29kZSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgIGV4cGVjdCh0eXBlLmVuY29kZS5ieXRlcykudG9CZShcbiAgICAgICAgICBpdGVtQnl0ZXMgKiBpdGVtcy5sZW5ndGggKyBsZW5ndGhUeXBlLmVuY29kZS5ieXRlc1xuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ2RlY29kZScsICgpID0+IHtcbiAgICAgICAgY29uc3QgZmlyc3QgPSAxO1xuICAgICAgICBjb25zdCBzZWNvbmQgPSAyO1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtmaXJzdCwgc2Vjb25kXTtcblxuICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gaXRlbXM7XG4gICAgICAgIGNvbnN0IGl0ZW1CeXRlcyA9IDM7XG4gICAgICAgIGNvbnN0IGxlbmd0aEJ5dGVzID0gMztcblxuICAgICAgICBjb25zdCBpdGVtVHlwZSA9IHtcbiAgICAgICAgICBkZWNvZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuY29kZSgpIHt9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGl0ZW1UeXBlLmRlY29kZS5ieXRlcyA9IGl0ZW1CeXRlcztcblxuICAgICAgICBjb25zdCBsZW5ndGhUeXBlID0ge1xuICAgICAgICAgIGRlY29kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBsZW5ndGggKiBpdGVtQnl0ZXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmNvZGUoKSB7fSxcbiAgICAgICAgfTtcblxuICAgICAgICBsZW5ndGhUeXBlLmRlY29kZS5ieXRlcyA9IGxlbmd0aEJ5dGVzO1xuXG4gICAgICAgIGNvbnN0IHR5cGUgPSBhcnJheShpdGVtVHlwZSwgbGVuZ3RoVHlwZSwgJ2J5dGVzJyk7XG5cbiAgICAgICAgZXhwZWN0KHR5cGUuZGVjb2RlKHJzdHJlYW0pKS50b0VxdWFsKFtmaXJzdCwgc2Vjb25kXSk7XG4gICAgICAgIGV4cGVjdCh0eXBlLmRlY29kZS5ieXRlcykudG9CZShpdGVtQnl0ZXMgKiBsZW5ndGggKyBsZW5ndGhCeXRlcyk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdCgnZW5jb2RpbmdMZW5ndGgnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWzEwLCAyMF07XG4gICAgICAgIGNvbnN0IGl0ZW1CeXRlcyA9IDM7XG4gICAgICAgIGNvbnN0IGxlbmd0aEJ5dGVzID0gNTtcblxuICAgICAgICBjb25zdCBsZW5ndGhUeXBlID0ge1xuICAgICAgICAgIGVuY29kZSgpIHt9LFxuICAgICAgICAgIGRlY29kZSgpIHt9LFxuICAgICAgICAgIGVuY29kaW5nTGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aEJ5dGVzO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaXRlbVR5cGUgPSB7XG4gICAgICAgICAgZW5jb2RlKCkge30sXG4gICAgICAgICAgZGVjb2RlKCkge30sXG4gICAgICAgICAgZW5jb2RpbmdMZW5ndGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbUJ5dGVzO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IGFycmF5KGl0ZW1UeXBlLCBsZW5ndGhUeXBlLCAnYnl0ZXMnKTtcblxuICAgICAgICBleHBlY3QodHlwZS5lbmNvZGluZ0xlbmd0aChpdGVtcykpLnRvQmUoXG4gICAgICAgICAgaXRlbXMubGVuZ3RoICogaXRlbUJ5dGVzICsgbGVuZ3RoQnl0ZXNcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnaXRlbSBpcyBhbiB1c2VyIGRlZmluZWQgdHlwZScsICgpID0+IHtcbiAgICB0ZXN0KCdlbmNvZGUnLCAoKSA9PiB7XG4gICAgICBjb25zdCB3c3RyZWFtID0ge307XG4gICAgICBjb25zdCBpdGVtcyA9IFt7IGE6IDEwMCB9LCB7IGE6IDIwMCB9LCB7IGE6IDMwMCB9XTtcbiAgICAgIGNvbnN0IGl0ZW1CeXRlcyA9IDQ7XG5cbiAgICAgIGNvbnN0IHNjaGVtYSA9IHtcbiAgICAgICAgYToge1xuICAgICAgICAgIGVuY29kZTogamVzdC5mbigpLFxuICAgICAgICAgIGRlY29kZSgpIHt9LFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgc2NoZW1hLmEuZW5jb2RlLmJ5dGVzID0gaXRlbUJ5dGVzO1xuXG4gICAgICBjb25zdCB0eXBlID0gYXJyYXkoc2NoZW1hLCBpdGVtcy5sZW5ndGgpO1xuICAgICAgdHlwZS5lbmNvZGUoaXRlbXMsIHdzdHJlYW0pO1xuXG4gICAgICBleHBlY3Qoc2NoZW1hLmEuZW5jb2RlKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoaXRlbXMubGVuZ3RoKTtcbiAgICAgIGV4cGVjdCh0eXBlLmVuY29kZS5ieXRlcykudG9CZShpdGVtQnl0ZXMgKiBpdGVtcy5sZW5ndGgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnZGVjb2RlJywgKCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RJdGVtID0gMTtcbiAgICAgIGNvbnN0IHNlY29uZEl0ZW0gPSAyO1xuICAgICAgY29uc3QgaXRlbXMgPSBbZmlyc3RJdGVtLCBzZWNvbmRJdGVtXTtcblxuICAgICAgY29uc3QgeyBsZW5ndGggfSA9IGl0ZW1zO1xuICAgICAgY29uc3QgaXRlbUJ5dGVzID0gMjtcblxuICAgICAgY29uc3QgaXRlbVR5cGUgPSB7XG4gICAgICAgIGRlY29kZSgpIHtcbiAgICAgICAgICByZXR1cm4gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5jb2RlKCkge30sXG4gICAgICB9O1xuXG4gICAgICBpdGVtVHlwZS5kZWNvZGUuYnl0ZXMgPSBpdGVtQnl0ZXM7XG5cbiAgICAgIGNvbnN0IHNjaGVtYSA9IHtcbiAgICAgICAgYTogaXRlbVR5cGUsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB0eXBlID0gYXJyYXkoc2NoZW1hLCBsZW5ndGgpO1xuXG4gICAgICBleHBlY3QodHlwZS5kZWNvZGUocnN0cmVhbSkpLnRvRXF1YWwoW1xuICAgICAgICB7IGE6IGZpcnN0SXRlbSB9LFxuICAgICAgICB7IGE6IHNlY29uZEl0ZW0gfSxcbiAgICAgIF0pO1xuICAgICAgZXhwZWN0KHR5cGUuZGVjb2RlLmJ5dGVzKS50b0JlKGl0ZW1CeXRlcyAqIGxlbmd0aCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdlbmNvZGluZ0xlbmd0aCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1CeXRlcyA9IDM7XG4gICAgICBjb25zdCBpdGVtcyA9IFt7IGE6IDEwMCB9LCB7IGE6IDIwMCB9LCB7IGE6IDMwMCB9XTtcblxuICAgICAgY29uc3Qgc2NoZW1hID0ge1xuICAgICAgICBhOiB7XG4gICAgICAgICAgZW5jb2RlKCkge30sXG4gICAgICAgICAgZGVjb2RlKCkge30sXG4gICAgICAgICAgZW5jb2RpbmdMZW5ndGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbUJ5dGVzO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB0eXBlID0gYXJyYXkoc2NoZW1hLCBpdGVtcy5sZW5ndGgpO1xuXG4gICAgICBleHBlY3QodHlwZS5lbmNvZGluZ0xlbmd0aChpdGVtcykpLnRvQmUoaXRlbUJ5dGVzICogaXRlbXMubGVuZ3RoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2xlbmd0aCBpcyBmdW5jdGlvbicsICgpID0+IHtcbiAgICBkZXNjcmliZSgnbGVuZ3RoIGlzIHRoZSBudW1iZXIgb2YgaXRlbXMnLCAoKSA9PiB7XG4gICAgICB0ZXN0KCdkZWNvZGUnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gMTtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gMjtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBbZmlyc3QsIHNlY29uZF07XG5cbiAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IGl0ZW1zO1xuICAgICAgICBjb25zdCBieXRlcyA9IDM7XG5cbiAgICAgICAgY29uc3QgaXRlbVR5cGUgPSB7XG4gICAgICAgICAgZGVjb2RlKCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmNvZGUoKSB7fSxcbiAgICAgICAgfTtcblxuICAgICAgICBpdGVtVHlwZS5kZWNvZGUuYnl0ZXMgPSBieXRlcztcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IGxlbmd0aCk7XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IGFycmF5KGl0ZW1UeXBlLCBjYWxsYmFjayk7XG5cbiAgICAgICAgZXhwZWN0KHR5cGUuZGVjb2RlKHJzdHJlYW0pKS50b0VxdWFsKFtmaXJzdCwgc2Vjb25kXSk7XG4gICAgICAgIGV4cGVjdChjYWxsYmFjaykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgICBleHBlY3QodHlwZS5kZWNvZGUuYnl0ZXMpLnRvQmUoYnl0ZXMgKiBsZW5ndGgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ2VuY29kZScsICgpID0+IHtcbiAgICAgICAgY29uc3Qgd3N0cmVhbSA9IHt9O1xuICAgICAgICBjb25zdCBpdGVtcyA9IFsxMDAsIDIwMCwgMzAwXTtcbiAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IGl0ZW1zO1xuICAgICAgICBjb25zdCBieXRlcyA9IDQ7XG5cbiAgICAgICAgY29uc3QgaXRlbVR5cGUgPSB7XG4gICAgICAgICAgZGVjb2RlKCkge30sXG4gICAgICAgICAgZW5jb2RlOiBqZXN0LmZuKCksXG4gICAgICAgIH07XG5cbiAgICAgICAgaXRlbVR5cGUuZW5jb2RlLmJ5dGVzID0gYnl0ZXM7XG5cbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IGxlbmd0aCk7XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IGFycmF5KGl0ZW1UeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIHR5cGUuZW5jb2RlKGl0ZW1zLCB3c3RyZWFtKTtcblxuICAgICAgICBleHBlY3QoY2FsbGJhY2spLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgICAgZXhwZWN0KGl0ZW1UeXBlLmVuY29kZSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgIGV4cGVjdCh0eXBlLmVuY29kZS5ieXRlcykudG9CZShieXRlcyAqIGl0ZW1zLmxlbmd0aCk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdCgnZW5jb2RpbmdMZW5ndGgnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWzEwLCAyMF07XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gMztcblxuICAgICAgICBjb25zdCBpdGVtVHlwZSA9IHtcbiAgICAgICAgICBlbmNvZGUoKSB7fSxcbiAgICAgICAgICBkZWNvZGUoKSB7fSxcbiAgICAgICAgICBlbmNvZGluZ0xlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlcztcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHR5cGUgPSBhcnJheShpdGVtVHlwZSwgKCkgPT4ge30pO1xuXG4gICAgICAgIGV4cGVjdCh0eXBlLmVuY29kaW5nTGVuZ3RoKGl0ZW1zKSkudG9CZShpdGVtcy5sZW5ndGggKiBieXRlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdsZW5ndGggaXMgdGhlIG51bWJlciBvZiBieXRlcycsICgpID0+IHtcbiAgICAgIHRlc3QoJ2RlY29kZScsICgpID0+IHtcbiAgICAgICAgY29uc3QgZmlyc3QgPSAxO1xuICAgICAgICBjb25zdCBzZWNvbmQgPSAyO1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtmaXJzdCwgc2Vjb25kXTtcblxuICAgICAgICBjb25zdCBieXRlcyA9IDM7XG4gICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBpdGVtcztcblxuICAgICAgICBjb25zdCBpdGVtVHlwZSA9IHtcbiAgICAgICAgICBkZWNvZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuY29kZSgpIHt9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGl0ZW1UeXBlLmRlY29kZS5ieXRlcyA9IGJ5dGVzO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gbGVuZ3RoICogYnl0ZXMpO1xuXG4gICAgICAgIGNvbnN0IHR5cGUgPSBhcnJheShpdGVtVHlwZSwgY2FsbGJhY2ssICdieXRlcycpO1xuXG4gICAgICAgIGV4cGVjdCh0eXBlLmRlY29kZShyc3RyZWFtKSkudG9FcXVhbChbZmlyc3QsIHNlY29uZF0pO1xuICAgICAgICBleHBlY3QoY2FsbGJhY2spLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgICAgZXhwZWN0KHR5cGUuZGVjb2RlLmJ5dGVzKS50b0JlKGxlbmd0aCAqIGJ5dGVzKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KCdlbmNvZGUnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHdzdHJlYW0gPSB7fTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBbMTAwLCAyMDAsIDMwMF07XG5cbiAgICAgICAgY29uc3QgYnl0ZXMgPSA0O1xuICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gaXRlbXM7XG5cbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IGxlbmd0aCAqIGJ5dGVzKTtcblxuICAgICAgICBjb25zdCBpdGVtVHlwZSA9IHtcbiAgICAgICAgICBkZWNvZGUoKSB7fSxcbiAgICAgICAgICBlbmNvZGU6IGplc3QuZm4oKSxcbiAgICAgICAgICBlbmNvZGluZ0xlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlcztcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGl0ZW1UeXBlLmVuY29kZS5ieXRlcyA9IGJ5dGVzO1xuXG4gICAgICAgIGNvbnN0IHR5cGUgPSBhcnJheShpdGVtVHlwZSwgY2FsbGJhY2ssICdieXRlcycpO1xuICAgICAgICB0eXBlLmVuY29kZShpdGVtcywgd3N0cmVhbSk7XG5cbiAgICAgICAgZXhwZWN0KGNhbGxiYWNrKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgIGV4cGVjdChpdGVtVHlwZS5lbmNvZGUpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyhsZW5ndGgpO1xuICAgICAgICBleHBlY3QodHlwZS5lbmNvZGUuYnl0ZXMpLnRvQmUoYnl0ZXMgKiBsZW5ndGgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ2VuY29kaW5nTGVuZ3RoJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBpdGVtcyA9IFsxMCwgMjBdO1xuICAgICAgICBjb25zdCBieXRlcyA9IDM7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGl0ZW1zLmxlbmd0aCAqIGJ5dGVzO1xuXG4gICAgICAgIGNvbnN0IGl0ZW1UeXBlID0ge1xuICAgICAgICAgIGVuY29kZSgpIHt9LFxuICAgICAgICAgIGRlY29kZSgpIHt9LFxuICAgICAgICAgIGVuY29kaW5nTGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgc2NoZW1hID0gYXJyYXkoaXRlbVR5cGUsICgpID0+IHt9LCAnYnl0ZXMnKTtcblxuICAgICAgICBleHBlY3Qoc2NoZW1hLmVuY29kaW5nTGVuZ3RoKGl0ZW1zKSkudG9CZShsZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXX0=