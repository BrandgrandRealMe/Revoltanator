{"version":3,"sources":["reserved.js"],"names":["reserved","require","describe","test","size","wstream","itemType","encode","jest","fn","mockImplementation","bytes","decode","type","expect","toHaveBeenCalledTimes","toBe","rstream","toBeUndefined","toEqual","value","length","encodingLength","callback"],"mappings":"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","file":"reserved.js","sourcesContent":["'use strict';\n\nconst reserved = require('types/reserved');\n\ndescribe('reserved', () => {\n  describe('argument `size` is number', () => {\n    test('encode', () => {\n      const size = 2;\n      const wstream = {};\n\n      const itemType = {\n        encode: jest.fn().mockImplementation(() => {\n          itemType.encode.bytes = size;\n        }),\n        decode() {},\n      };\n\n      const type = reserved(itemType, size);\n\n      type.encode('qqq', wstream);\n      expect(itemType.encode).toHaveBeenCalledTimes(size);\n      expect(type.encode.bytes).toBe(itemType.encode.bytes * size);\n    });\n\n    test('decode', () => {\n      const size = 2;\n      const rstream = {};\n      const bytes = 3;\n\n      const itemType = {\n        decode: jest.fn(),\n        encode() {},\n      };\n\n      itemType.decode.bytes = bytes;\n\n      const type = reserved(itemType, size);\n\n      expect(type.decode(rstream)).toBeUndefined();\n      expect(itemType.decode).toHaveBeenCalledTimes(size);\n      expect(type.decode.bytes).toEqual(size * bytes);\n    });\n\n    test('encodingLength', () => {\n      const size = 4;\n      const value = 1;\n      const length = 2;\n\n      const itemType = {\n        decode() {},\n        encode() {},\n        encodingLength() {\n          return length;\n        },\n      };\n\n      const type = reserved(itemType, size);\n\n      expect(type.encodingLength(value)).toBe(size * length);\n    });\n  });\n\n  describe('argument `size` is function', () => {\n    test('decode', () => {\n      const bytes = 10;\n      const size = 2;\n      const rstream = {};\n\n      const callback = jest.fn().mockImplementation(() => size);\n\n      const itemType = {\n        decode: jest.fn(),\n        encode() {},\n      };\n\n      itemType.decode.bytes = bytes;\n      const type = reserved(itemType, callback);\n\n      expect(type.decode(rstream)).toBeUndefined();\n      expect(callback).toHaveBeenCalledTimes(1);\n      expect(type.decode.bytes).toBe(bytes * size);\n    });\n\n    test('encode', () => {\n      const size = 2;\n      const bytes = 3;\n      const wstream = {};\n      const callback = jest.fn().mockImplementation(() => size);\n\n      const itemType = {\n        encode: jest.fn().mockImplementation(() => {\n          itemType.encode.bytes = bytes;\n        }),\n        decode() {},\n      };\n\n      const type = reserved(itemType, callback);\n      type.encode('qqq', wstream);\n\n      expect(itemType.encode).toHaveBeenCalledTimes(size);\n      expect(callback).toHaveBeenCalledTimes(1);\n      expect(type.encode.bytes).toBe(itemType.encode.bytes * size);\n    });\n\n    test('encodingLength', () => {\n      const size = 2;\n      const value = 1;\n      const callback = jest.fn().mockImplementation(() => size);\n      const length = 2;\n\n      const itemType = {\n        decode() {},\n        encode() {},\n        encodingLength() {\n          return length;\n        },\n      };\n\n      const type = reserved(itemType, callback);\n\n      expect(type.encodingLength(value)).toBe(size * length);\n      expect(callback).toHaveBeenCalledTimes(1);\n    });\n  });\n});\n"]}