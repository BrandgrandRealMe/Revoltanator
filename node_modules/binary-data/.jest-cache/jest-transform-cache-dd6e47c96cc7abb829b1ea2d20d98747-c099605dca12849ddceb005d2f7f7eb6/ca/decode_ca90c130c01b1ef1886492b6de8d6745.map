{"version":3,"sources":["decode.js"],"names":["BinaryStream","require","NotEnoughDataError","describe","test","buf","Buffer","from","stream","append","expect","length","toBe","wantRead","result","readBuffer","toEqual","requestedBytes","toThrow","suites","Number","MAX_SAFE_INTEGER","allocUnsafe","suite","read","write","fill"],"mappings":"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","file":"decode.js","sourcesContent":["'use strict';\n\nconst BinaryStream = require('lib/binary-stream');\nconst NotEnoughDataError = require('lib/not-enough-data-error');\n\ndescribe('decode', () => {\n  test('readBuffer', () => {\n    const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6]);\n    const stream = new BinaryStream();\n    stream.append(buf);\n    expect(stream.length).toBe(buf.length);\n\n    const wantRead = 2;\n\n    const result = stream.readBuffer(wantRead);\n    expect(stream.length).toBe(buf.length - wantRead);\n    expect(result).toEqual(Buffer.from([0x1, 0x2]));\n  });\n\n  test('readBuffer # out of bounds', () => {\n    const buf = Buffer.from([0x1, 0x2]);\n    const stream = new BinaryStream();\n    stream.append(buf);\n    const requestedBytes = buf.length + 1;\n\n    expect(() => stream.readBuffer(requestedBytes)).toThrow(NotEnoughDataError);\n  });\n\n  test('default numbers', () => {\n    const suites = [\n      /* Type, size, test value */\n      ['DoubleBE', 8, Number.MAX_SAFE_INTEGER / 2],\n      ['DoubleLE', 8, Number.MAX_SAFE_INTEGER / 2],\n\n      ['FloatBE', 4, 0.5],\n      ['FloatLE', 4, 0.5],\n\n      ['Int8', 1, 127],\n      ['UInt8', 1, 255],\n\n      ['Int16BE', 2, 0x7fff - 1],\n      ['Int16LE', 2, 0x7fff - 1],\n\n      ['UInt16BE', 2, 0xffff - 1],\n      ['UInt16LE', 2, 0xffff - 1],\n\n      ['Int32BE', 4, 0x7fffffff - 1],\n      ['Int32LE', 4, 0x7fffffff - 1],\n\n      ['UInt32BE', 4, 0xffffffff - 1],\n      ['UInt32LE', 4, 0xffffffff - 1],\n    ];\n\n    const buf = Buffer.allocUnsafe(10);\n\n    for (const suite of suites) {\n      const read = `read${suite[0]}`;\n      const write = `write${suite[0]}`;\n\n      buf.fill(0);\n      buf[write](suite[2], 0);\n      const stream = new BinaryStream();\n      stream.append(buf);\n\n      expect(stream[read]()).toBe(suite[2]);\n      expect(stream.length).toBe(buf.length - suite[1]);\n    }\n  });\n\n  describe('custom numbers', () => {\n    const suites = [\n      /* Type, size, test value */\n      ['IntBE', 3, 0x7fffff - 1],\n      ['UIntBE', 3, 0xffffff - 1],\n\n      ['IntLE', 3, 0x7fffff - 1],\n      ['UIntLE', 3, 0xffffff - 1],\n    ];\n\n    const buf = Buffer.allocUnsafe(5);\n\n    for (const suite of suites) {\n      const read = `read${suite[0]}`;\n      const write = `write${suite[0]}`;\n\n      test(read, () => {\n        buf.fill(0);\n        buf[write](suite[2], 0, suite[1]);\n        const stream = new BinaryStream();\n        stream.append(buf);\n\n        expect(stream[read](suite[1])).toBe(suite[2]);\n        expect(stream.length).toBe(buf.length - suite[1]);\n      });\n    }\n  });\n});\n"]}