{"version":3,"sources":["select.js"],"names":["when","require","select","symbols","describe","defaultValue","defaultBytes","defaultType","decode","encode","bytes","firstValue","firstBytes","firstType","secondValue","secondBytes","secondType","test","type","expect","toEqual","skip","toBe","undefined"],"mappings":"AAAA;;AAEA,MAAMA,OAAOC,QAAQ,YAAR,CAAb;AACA,MAAMC,SAASD,QAAQ,cAAR,CAAf;AACA,MAAME,UAAUF,QAAQ,kBAAR,CAAhB;;AAEAG,SAAS,QAAT,EAAmB,MAAM;AACvB,QAAMC,eAAe,GAArB;AACA,QAAMC,eAAe,CAArB;;AAEA,QAAMC,cAAc;AAClBC,YAAQ,MAAMH,YADI;AAElBI,aAAS,CAAE;AAFO,GAApB;;AAKAF,cAAYC,MAAZ,CAAmBE,KAAnB,GAA2BJ,YAA3B;;AAEA,QAAMK,aAAa,GAAnB;AACA,QAAMC,aAAa,CAAnB;;AAEA,QAAMC,YAAY;AAChBL,YAAQ,MAAMG,UADE;AAEhBF,aAAS,CAAE;AAFK,GAAlB;;AAKAI,YAAUL,MAAV,CAAiBE,KAAjB,GAAyBE,UAAzB;;AAEA,QAAME,cAAc,GAApB;AACA,QAAMC,cAAc,CAApB;;AAEA,QAAMC,aAAa;AACjBR,YAAQ,MAAMM,WADG;AAEjBL,aAAS,CAAE;AAFM,GAAnB;;AAKAO,aAAWR,MAAX,CAAkBE,KAAlB,GAA0BK,WAA1B;;AAEAE,OAAK,qBAAL,EAA4B,MAAM;AAChC,UAAMC,OAAOhB,OACXF,KAAK,MAAM,IAAX,EAAiBa,SAAjB,CADW,EAEXb,KAAK,MAAM,KAAX,EAAkBgB,UAAlB,CAFW,EAGXT,WAHW,CAAb;;AAMAY,WAAOD,KAAKV,MAAL,CAAY,EAAZ,CAAP,EAAwBY,OAAxB,CAAgCT,UAAhC;AACAQ,WAAOD,KAAKV,MAAL,CAAYE,KAAnB,EAA0BU,OAA1B,CAAkCR,UAAlC;AACAO,WAAOD,KAAKf,QAAQkB,IAAb,CAAP,EAA2BD,OAA3B,CAAmC,KAAnC;AACD,GAVD;;AAYAH,OAAK,sBAAL,EAA6B,MAAM;AACjC,UAAMC,OAAOhB,OACXF,KAAK,MAAM,KAAX,EAAkBa,SAAlB,CADW,EAEXb,KAAK,MAAM,IAAX,EAAiBgB,UAAjB,CAFW,EAGXT,WAHW,CAAb;;AAMAY,WAAOD,KAAKV,MAAL,CAAY,EAAZ,CAAP,EAAwBY,OAAxB,CAAgCN,WAAhC;AACAK,WAAOD,KAAKV,MAAL,CAAYE,KAAnB,EAA0BU,OAA1B,CAAkCL,WAAlC;AACAI,WAAOD,KAAKf,QAAQkB,IAAb,CAAP,EAA2BD,OAA3B,CAAmC,KAAnC;AACD,GAVD;;AAYAH,OAAK,uBAAL,EAA8B,MAAM;AAClC,UAAMC,OAAOhB,OACXF,KAAK,MAAM,KAAX,EAAkBa,SAAlB,CADW,EAEXb,KAAK,MAAM,KAAX,EAAkBgB,UAAlB,CAFW,EAGXT,WAHW,CAAb;;AAMAY,WAAOD,KAAKV,MAAL,CAAY,EAAZ,CAAP,EAAwBY,OAAxB,CAAgCf,YAAhC;AACAc,WAAOD,KAAKV,MAAL,CAAYE,KAAnB,EAA0BU,OAA1B,CAAkCd,YAAlC;AACAa,WAAOD,KAAKf,QAAQkB,IAAb,CAAP,EAA2BD,OAA3B,CAAmC,KAAnC;AACD,GAVD;;AAYAH,OAAK,mBAAL,EAA0B,MAAM;AAC9B,UAAMC,OAAOhB,OACXF,KAAK,MAAM,KAAX,EAAkBa,SAAlB,CADW,EAEXb,KAAK,MAAM,KAAX,EAAkBgB,UAAlB,CAFW,CAAb;AAIAE,SAAKV,MAAL,CAAY,EAAZ;;AAEAW,WAAOD,KAAKV,MAAL,CAAY,EAAZ,CAAP,EAAwBc,IAAxB,CAA6BC,SAA7B;AACAJ,WAAOD,KAAKV,MAAL,CAAYE,KAAnB,EAA0BU,OAA1B,CAAkC,CAAlC;AACAD,WAAOD,KAAKf,QAAQkB,IAAb,CAAP,EAA2BD,OAA3B,CAAmC,IAAnC;AACD,GAVD;AAWD,CA9ED","file":"select.js","sourcesContent":["'use strict';\n\nconst when = require('types/when');\nconst select = require('types/select');\nconst symbols = require('internal/symbols');\n\ndescribe('select', () => {\n  const defaultValue = 322;\n  const defaultBytes = 2;\n\n  const defaultType = {\n    decode: () => defaultValue,\n    encode() {},\n  };\n\n  defaultType.decode.bytes = defaultBytes;\n\n  const firstValue = 111;\n  const firstBytes = 3;\n\n  const firstType = {\n    decode: () => firstValue,\n    encode() {},\n  };\n\n  firstType.decode.bytes = firstBytes;\n\n  const secondValue = 222;\n  const secondBytes = 4;\n\n  const secondType = {\n    decode: () => secondValue,\n    encode() {},\n  };\n\n  secondType.decode.bytes = secondBytes;\n\n  test('decode first option', () => {\n    const type = select(\n      when(() => true, firstType),\n      when(() => false, secondType),\n      defaultType\n    );\n\n    expect(type.decode({})).toEqual(firstValue);\n    expect(type.decode.bytes).toEqual(firstBytes);\n    expect(type[symbols.skip]).toEqual(false);\n  });\n\n  test('decode second option', () => {\n    const type = select(\n      when(() => false, firstType),\n      when(() => true, secondType),\n      defaultType\n    );\n\n    expect(type.decode({})).toEqual(secondValue);\n    expect(type.decode.bytes).toEqual(secondBytes);\n    expect(type[symbols.skip]).toEqual(false);\n  });\n\n  test('decode default option', () => {\n    const type = select(\n      when(() => false, firstType),\n      when(() => false, secondType),\n      defaultType\n    );\n\n    expect(type.decode({})).toEqual(defaultValue);\n    expect(type.decode.bytes).toEqual(defaultBytes);\n    expect(type[symbols.skip]).toEqual(false);\n  });\n\n  test('skip after decode', () => {\n    const type = select(\n      when(() => false, firstType),\n      when(() => false, secondType)\n    );\n    type.decode({});\n\n    expect(type.decode({})).toBe(undefined);\n    expect(type.decode.bytes).toEqual(0);\n    expect(type[symbols.skip]).toEqual(true);\n  });\n});\n"]}