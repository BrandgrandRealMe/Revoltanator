dd3e8deba97a4ff4a94431bea53fe200
'use strict';

const when = require('types/when');
const select = require('types/select');
const symbols = require('internal/symbols');

describe('select', () => {
  const defaultValue = 322;
  const defaultBytes = 2;

  const defaultType = {
    decode: () => defaultValue,
    encode() {}
  };

  defaultType.decode.bytes = defaultBytes;

  const firstValue = 111;
  const firstBytes = 3;

  const firstType = {
    decode: () => firstValue,
    encode() {}
  };

  firstType.decode.bytes = firstBytes;

  const secondValue = 222;
  const secondBytes = 4;

  const secondType = {
    decode: () => secondValue,
    encode() {}
  };

  secondType.decode.bytes = secondBytes;

  test('decode first option', () => {
    const type = select(when(() => true, firstType), when(() => false, secondType), defaultType);

    expect(type.decode({})).toEqual(firstValue);
    expect(type.decode.bytes).toEqual(firstBytes);
    expect(type[symbols.skip]).toEqual(false);
  });

  test('decode second option', () => {
    const type = select(when(() => false, firstType), when(() => true, secondType), defaultType);

    expect(type.decode({})).toEqual(secondValue);
    expect(type.decode.bytes).toEqual(secondBytes);
    expect(type[symbols.skip]).toEqual(false);
  });

  test('decode default option', () => {
    const type = select(when(() => false, firstType), when(() => false, secondType), defaultType);

    expect(type.decode({})).toEqual(defaultValue);
    expect(type.decode.bytes).toEqual(defaultBytes);
    expect(type[symbols.skip]).toEqual(false);
  });

  test('skip after decode', () => {
    const type = select(when(() => false, firstType), when(() => false, secondType));
    type.decode({});

    expect(type.decode({})).toBe(undefined);
    expect(type.decode.bytes).toEqual(0);
    expect(type[symbols.skip]).toEqual(true);
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNlbGVjdC5qcyJdLCJuYW1lcyI6WyJ3aGVuIiwicmVxdWlyZSIsInNlbGVjdCIsInN5bWJvbHMiLCJkZXNjcmliZSIsImRlZmF1bHRWYWx1ZSIsImRlZmF1bHRCeXRlcyIsImRlZmF1bHRUeXBlIiwiZGVjb2RlIiwiZW5jb2RlIiwiYnl0ZXMiLCJmaXJzdFZhbHVlIiwiZmlyc3RCeXRlcyIsImZpcnN0VHlwZSIsInNlY29uZFZhbHVlIiwic2Vjb25kQnl0ZXMiLCJzZWNvbmRUeXBlIiwidGVzdCIsInR5cGUiLCJleHBlY3QiLCJ0b0VxdWFsIiwic2tpcCIsInRvQmUiLCJ1bmRlZmluZWQiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLE1BQU1BLE9BQU9DLFFBQVEsWUFBUixDQUFiO0FBQ0EsTUFBTUMsU0FBU0QsUUFBUSxjQUFSLENBQWY7QUFDQSxNQUFNRSxVQUFVRixRQUFRLGtCQUFSLENBQWhCOztBQUVBRyxTQUFTLFFBQVQsRUFBbUIsTUFBTTtBQUN2QixRQUFNQyxlQUFlLEdBQXJCO0FBQ0EsUUFBTUMsZUFBZSxDQUFyQjs7QUFFQSxRQUFNQyxjQUFjO0FBQ2xCQyxZQUFRLE1BQU1ILFlBREk7QUFFbEJJLGFBQVMsQ0FBRTtBQUZPLEdBQXBCOztBQUtBRixjQUFZQyxNQUFaLENBQW1CRSxLQUFuQixHQUEyQkosWUFBM0I7O0FBRUEsUUFBTUssYUFBYSxHQUFuQjtBQUNBLFFBQU1DLGFBQWEsQ0FBbkI7O0FBRUEsUUFBTUMsWUFBWTtBQUNoQkwsWUFBUSxNQUFNRyxVQURFO0FBRWhCRixhQUFTLENBQUU7QUFGSyxHQUFsQjs7QUFLQUksWUFBVUwsTUFBVixDQUFpQkUsS0FBakIsR0FBeUJFLFVBQXpCOztBQUVBLFFBQU1FLGNBQWMsR0FBcEI7QUFDQSxRQUFNQyxjQUFjLENBQXBCOztBQUVBLFFBQU1DLGFBQWE7QUFDakJSLFlBQVEsTUFBTU0sV0FERztBQUVqQkwsYUFBUyxDQUFFO0FBRk0sR0FBbkI7O0FBS0FPLGFBQVdSLE1BQVgsQ0FBa0JFLEtBQWxCLEdBQTBCSyxXQUExQjs7QUFFQUUsT0FBSyxxQkFBTCxFQUE0QixNQUFNO0FBQ2hDLFVBQU1DLE9BQU9oQixPQUNYRixLQUFLLE1BQU0sSUFBWCxFQUFpQmEsU0FBakIsQ0FEVyxFQUVYYixLQUFLLE1BQU0sS0FBWCxFQUFrQmdCLFVBQWxCLENBRlcsRUFHWFQsV0FIVyxDQUFiOztBQU1BWSxXQUFPRCxLQUFLVixNQUFMLENBQVksRUFBWixDQUFQLEVBQXdCWSxPQUF4QixDQUFnQ1QsVUFBaEM7QUFDQVEsV0FBT0QsS0FBS1YsTUFBTCxDQUFZRSxLQUFuQixFQUEwQlUsT0FBMUIsQ0FBa0NSLFVBQWxDO0FBQ0FPLFdBQU9ELEtBQUtmLFFBQVFrQixJQUFiLENBQVAsRUFBMkJELE9BQTNCLENBQW1DLEtBQW5DO0FBQ0QsR0FWRDs7QUFZQUgsT0FBSyxzQkFBTCxFQUE2QixNQUFNO0FBQ2pDLFVBQU1DLE9BQU9oQixPQUNYRixLQUFLLE1BQU0sS0FBWCxFQUFrQmEsU0FBbEIsQ0FEVyxFQUVYYixLQUFLLE1BQU0sSUFBWCxFQUFpQmdCLFVBQWpCLENBRlcsRUFHWFQsV0FIVyxDQUFiOztBQU1BWSxXQUFPRCxLQUFLVixNQUFMLENBQVksRUFBWixDQUFQLEVBQXdCWSxPQUF4QixDQUFnQ04sV0FBaEM7QUFDQUssV0FBT0QsS0FBS1YsTUFBTCxDQUFZRSxLQUFuQixFQUEwQlUsT0FBMUIsQ0FBa0NMLFdBQWxDO0FBQ0FJLFdBQU9ELEtBQUtmLFFBQVFrQixJQUFiLENBQVAsRUFBMkJELE9BQTNCLENBQW1DLEtBQW5DO0FBQ0QsR0FWRDs7QUFZQUgsT0FBSyx1QkFBTCxFQUE4QixNQUFNO0FBQ2xDLFVBQU1DLE9BQU9oQixPQUNYRixLQUFLLE1BQU0sS0FBWCxFQUFrQmEsU0FBbEIsQ0FEVyxFQUVYYixLQUFLLE1BQU0sS0FBWCxFQUFrQmdCLFVBQWxCLENBRlcsRUFHWFQsV0FIVyxDQUFiOztBQU1BWSxXQUFPRCxLQUFLVixNQUFMLENBQVksRUFBWixDQUFQLEVBQXdCWSxPQUF4QixDQUFnQ2YsWUFBaEM7QUFDQWMsV0FBT0QsS0FBS1YsTUFBTCxDQUFZRSxLQUFuQixFQUEwQlUsT0FBMUIsQ0FBa0NkLFlBQWxDO0FBQ0FhLFdBQU9ELEtBQUtmLFFBQVFrQixJQUFiLENBQVAsRUFBMkJELE9BQTNCLENBQW1DLEtBQW5DO0FBQ0QsR0FWRDs7QUFZQUgsT0FBSyxtQkFBTCxFQUEwQixNQUFNO0FBQzlCLFVBQU1DLE9BQU9oQixPQUNYRixLQUFLLE1BQU0sS0FBWCxFQUFrQmEsU0FBbEIsQ0FEVyxFQUVYYixLQUFLLE1BQU0sS0FBWCxFQUFrQmdCLFVBQWxCLENBRlcsQ0FBYjtBQUlBRSxTQUFLVixNQUFMLENBQVksRUFBWjs7QUFFQVcsV0FBT0QsS0FBS1YsTUFBTCxDQUFZLEVBQVosQ0FBUCxFQUF3QmMsSUFBeEIsQ0FBNkJDLFNBQTdCO0FBQ0FKLFdBQU9ELEtBQUtWLE1BQUwsQ0FBWUUsS0FBbkIsRUFBMEJVLE9BQTFCLENBQWtDLENBQWxDO0FBQ0FELFdBQU9ELEtBQUtmLFFBQVFrQixJQUFiLENBQVAsRUFBMkJELE9BQTNCLENBQW1DLElBQW5DO0FBQ0QsR0FWRDtBQVdELENBOUVEIiwiZmlsZSI6InNlbGVjdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgd2hlbiA9IHJlcXVpcmUoJ3R5cGVzL3doZW4nKTtcbmNvbnN0IHNlbGVjdCA9IHJlcXVpcmUoJ3R5cGVzL3NlbGVjdCcpO1xuY29uc3Qgc3ltYm9scyA9IHJlcXVpcmUoJ2ludGVybmFsL3N5bWJvbHMnKTtcblxuZGVzY3JpYmUoJ3NlbGVjdCcsICgpID0+IHtcbiAgY29uc3QgZGVmYXVsdFZhbHVlID0gMzIyO1xuICBjb25zdCBkZWZhdWx0Qnl0ZXMgPSAyO1xuXG4gIGNvbnN0IGRlZmF1bHRUeXBlID0ge1xuICAgIGRlY29kZTogKCkgPT4gZGVmYXVsdFZhbHVlLFxuICAgIGVuY29kZSgpIHt9LFxuICB9O1xuXG4gIGRlZmF1bHRUeXBlLmRlY29kZS5ieXRlcyA9IGRlZmF1bHRCeXRlcztcblxuICBjb25zdCBmaXJzdFZhbHVlID0gMTExO1xuICBjb25zdCBmaXJzdEJ5dGVzID0gMztcblxuICBjb25zdCBmaXJzdFR5cGUgPSB7XG4gICAgZGVjb2RlOiAoKSA9PiBmaXJzdFZhbHVlLFxuICAgIGVuY29kZSgpIHt9LFxuICB9O1xuXG4gIGZpcnN0VHlwZS5kZWNvZGUuYnl0ZXMgPSBmaXJzdEJ5dGVzO1xuXG4gIGNvbnN0IHNlY29uZFZhbHVlID0gMjIyO1xuICBjb25zdCBzZWNvbmRCeXRlcyA9IDQ7XG5cbiAgY29uc3Qgc2Vjb25kVHlwZSA9IHtcbiAgICBkZWNvZGU6ICgpID0+IHNlY29uZFZhbHVlLFxuICAgIGVuY29kZSgpIHt9LFxuICB9O1xuXG4gIHNlY29uZFR5cGUuZGVjb2RlLmJ5dGVzID0gc2Vjb25kQnl0ZXM7XG5cbiAgdGVzdCgnZGVjb2RlIGZpcnN0IG9wdGlvbicsICgpID0+IHtcbiAgICBjb25zdCB0eXBlID0gc2VsZWN0KFxuICAgICAgd2hlbigoKSA9PiB0cnVlLCBmaXJzdFR5cGUpLFxuICAgICAgd2hlbigoKSA9PiBmYWxzZSwgc2Vjb25kVHlwZSksXG4gICAgICBkZWZhdWx0VHlwZVxuICAgICk7XG5cbiAgICBleHBlY3QodHlwZS5kZWNvZGUoe30pKS50b0VxdWFsKGZpcnN0VmFsdWUpO1xuICAgIGV4cGVjdCh0eXBlLmRlY29kZS5ieXRlcykudG9FcXVhbChmaXJzdEJ5dGVzKTtcbiAgICBleHBlY3QodHlwZVtzeW1ib2xzLnNraXBdKS50b0VxdWFsKGZhbHNlKTtcbiAgfSk7XG5cbiAgdGVzdCgnZGVjb2RlIHNlY29uZCBvcHRpb24nLCAoKSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IHNlbGVjdChcbiAgICAgIHdoZW4oKCkgPT4gZmFsc2UsIGZpcnN0VHlwZSksXG4gICAgICB3aGVuKCgpID0+IHRydWUsIHNlY29uZFR5cGUpLFxuICAgICAgZGVmYXVsdFR5cGVcbiAgICApO1xuXG4gICAgZXhwZWN0KHR5cGUuZGVjb2RlKHt9KSkudG9FcXVhbChzZWNvbmRWYWx1ZSk7XG4gICAgZXhwZWN0KHR5cGUuZGVjb2RlLmJ5dGVzKS50b0VxdWFsKHNlY29uZEJ5dGVzKTtcbiAgICBleHBlY3QodHlwZVtzeW1ib2xzLnNraXBdKS50b0VxdWFsKGZhbHNlKTtcbiAgfSk7XG5cbiAgdGVzdCgnZGVjb2RlIGRlZmF1bHQgb3B0aW9uJywgKCkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBzZWxlY3QoXG4gICAgICB3aGVuKCgpID0+IGZhbHNlLCBmaXJzdFR5cGUpLFxuICAgICAgd2hlbigoKSA9PiBmYWxzZSwgc2Vjb25kVHlwZSksXG4gICAgICBkZWZhdWx0VHlwZVxuICAgICk7XG5cbiAgICBleHBlY3QodHlwZS5kZWNvZGUoe30pKS50b0VxdWFsKGRlZmF1bHRWYWx1ZSk7XG4gICAgZXhwZWN0KHR5cGUuZGVjb2RlLmJ5dGVzKS50b0VxdWFsKGRlZmF1bHRCeXRlcyk7XG4gICAgZXhwZWN0KHR5cGVbc3ltYm9scy5za2lwXSkudG9FcXVhbChmYWxzZSk7XG4gIH0pO1xuXG4gIHRlc3QoJ3NraXAgYWZ0ZXIgZGVjb2RlJywgKCkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBzZWxlY3QoXG4gICAgICB3aGVuKCgpID0+IGZhbHNlLCBmaXJzdFR5cGUpLFxuICAgICAgd2hlbigoKSA9PiBmYWxzZSwgc2Vjb25kVHlwZSlcbiAgICApO1xuICAgIHR5cGUuZGVjb2RlKHt9KTtcblxuICAgIGV4cGVjdCh0eXBlLmRlY29kZSh7fSkpLnRvQmUodW5kZWZpbmVkKTtcbiAgICBleHBlY3QodHlwZS5kZWNvZGUuYnl0ZXMpLnRvRXF1YWwoMCk7XG4gICAgZXhwZWN0KHR5cGVbc3ltYm9scy5za2lwXSkudG9FcXVhbCh0cnVlKTtcbiAgfSk7XG59KTtcbiJdfQ==